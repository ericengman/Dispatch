---
phase: 17-claude-code-integration
plan: 04
type: execute
wave: 3
depends_on: ["17-01", "17-02"]
files_modified:
  - Dispatch/Services/EmbeddedTerminalBridge.swift
  - Dispatch/Views/Terminal/EmbeddedTerminalView.swift
  - Dispatch/Services/ExecutionStateMachine.swift
  - Dispatch/Views/MainView.swift
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Queue prompt dispatch uses embedded terminal PTY (not AppleScript)"
    - "Chain execution dispatches to embedded terminal"
    - "ExecutionManager can access embedded terminal coordinator"
  artifacts:
    - path: "Dispatch/Services/EmbeddedTerminalBridge.swift"
      provides: "Bridge singleton connecting ExecutionManager to terminal coordinator"
      exports: ["EmbeddedTerminalBridge"]
    - path: "Dispatch/Services/ExecutionStateMachine.swift"
      provides: "Embedded terminal dispatch path in execute()"
      contains: "EmbeddedTerminalBridge"
  key_links:
    - from: "Dispatch/Services/ExecutionStateMachine.swift"
      to: "EmbeddedTerminalBridge"
      via: "bridge.dispatchPrompt"
      pattern: "EmbeddedTerminalBridge\\.shared\\.dispatch"
    - from: "Dispatch/Views/Terminal/EmbeddedTerminalView.swift"
      to: "EmbeddedTerminalBridge"
      via: "register/unregister coordinator"
      pattern: "EmbeddedTerminalBridge\\.shared\\.register"
---

<objective>
Create bridge between ExecutionManager and embedded terminal for prompt dispatch.

Purpose: Close Gap 2 from verification - ExecutionManager.execute() calls TerminalService (AppleScript) instead of embedded terminal's dispatchPrompt method.
Output: Queue/Chain execution dispatches prompts via embedded terminal PTY when available.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-claude-code-integration/17-01-SUMMARY.md
@.planning/phases/17-claude-code-integration/17-02-SUMMARY.md
@Dispatch/Views/Terminal/EmbeddedTerminalView.swift
@Dispatch/Services/ExecutionStateMachine.swift
@Dispatch/Views/MainView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmbeddedTerminalBridge service</name>
  <files>Dispatch/Services/EmbeddedTerminalBridge.swift</files>
  <action>
  Create a new file `Dispatch/Services/EmbeddedTerminalBridge.swift`:

  ```swift
  //
  //  EmbeddedTerminalBridge.swift
  //  Dispatch
  //
  //  Bridge between ExecutionManager and embedded terminal coordinator
  //  Allows services to dispatch prompts to the active terminal without direct coupling
  //

  import Foundation
  import SwiftTerm

  /// Connects ExecutionManager to embedded terminal for prompt dispatch
  /// Coordinator registers/unregisters itself during lifecycle
  @MainActor
  final class EmbeddedTerminalBridge: ObservableObject {
      static let shared = EmbeddedTerminalBridge()

      /// Currently registered coordinator (nil if no terminal open)
      @Published private(set) var activeCoordinator: EmbeddedTerminalView.Coordinator?

      /// Terminal view for completion monitoring
      @Published private(set) var activeTerminal: LocalProcessTerminalView?

      private init() {}

      /// Register the active terminal coordinator
      /// Called by Coordinator.init or when terminal becomes active
      func register(coordinator: EmbeddedTerminalView.Coordinator, terminal: LocalProcessTerminalView) {
          activeCoordinator = coordinator
          activeTerminal = terminal
          logInfo("Embedded terminal registered for dispatch", category: .terminal)
      }

      /// Unregister when terminal closes
      /// Called by Coordinator.deinit
      func unregister() {
          activeCoordinator = nil
          activeTerminal = nil
          logInfo("Embedded terminal unregistered", category: .terminal)
      }

      /// Check if embedded terminal is available for dispatch
      var isAvailable: Bool {
          activeCoordinator?.isReadyForDispatch ?? false
      }

      /// Dispatch a prompt to the embedded terminal
      /// - Parameter prompt: The prompt text to send
      /// - Returns: true if dispatched, false if no terminal available
      func dispatchPrompt(_ prompt: String) -> Bool {
          guard let coordinator = activeCoordinator else {
              logDebug("Cannot dispatch: no active coordinator", category: .terminal)
              return false
          }

          return coordinator.dispatchPrompt(prompt)
      }
  }
  ```

  Key design decisions:
  - Singleton pattern matches other services (TerminalProcessRegistry, ExecutionStateMachine)
  - @MainActor ensures thread safety for SwiftUI integration
  - Holds weak-ish reference via optionals (coordinator/terminal cleared on unregister)
  - Published properties allow UI observation if needed
  </action>
  <verify>
  Build succeeds:
  ```bash
  xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build 2>&1 | tail -5
  ```

  File exists with expected exports:
  ```bash
  grep -n "class EmbeddedTerminalBridge" Dispatch/Services/EmbeddedTerminalBridge.swift
  grep -n "func dispatchPrompt" Dispatch/Services/EmbeddedTerminalBridge.swift
  ```
  </verify>
  <done>
  EmbeddedTerminalBridge singleton created with register/unregister/dispatchPrompt methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register coordinator with bridge</name>
  <files>Dispatch/Views/Terminal/EmbeddedTerminalView.swift</files>
  <action>
  Modify EmbeddedTerminalView.Coordinator to register with the bridge:

  1. In Coordinator.init (after super.init()):
  ```swift
  // Note: Can't register here since terminalView is nil at init time
  // Registration happens in makeNSView after terminal is assigned
  ```

  2. Modify makeNSView to register after setting coordinator.terminalView:
  After line `context.coordinator.terminalView = terminal`, add:
  ```swift
  // Register with bridge for ExecutionManager access
  EmbeddedTerminalBridge.shared.register(coordinator: context.coordinator, terminal: terminal)
  ```

  3. In Coordinator.deinit, before terminalView = nil:
  ```swift
  // Unregister from bridge
  EmbeddedTerminalBridge.shared.unregister()
  ```

  This ensures:
  - Bridge has active coordinator when terminal is visible
  - Bridge clears when terminal closes
  - No dangling references after deinit
  </action>
  <verify>
  Build succeeds:
  ```bash
  xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build 2>&1 | tail -5
  ```

  Registration/unregistration in place:
  ```bash
  grep -n "EmbeddedTerminalBridge" Dispatch/Views/Terminal/EmbeddedTerminalView.swift
  ```
  </verify>
  <done>
  Coordinator registers with bridge on terminal creation, unregisters on deinit.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire ExecutionManager to use bridge</name>
  <files>Dispatch/Services/ExecutionStateMachine.swift</files>
  <action>
  Modify ExecutionManager.execute() to prefer embedded terminal over AppleScript:

  In the execute() method (around line 477-489), replace the terminal dispatch logic:

  BEFORE:
  ```swift
  // Ensure Terminal is running
  let isRunning = await terminalService.isTerminalRunning()
  if !isRunning {
      try await terminalService.launchTerminal()
  }

  // Send the prompt
  try await terminalService.sendPrompt(
      content,
      toWindowId: targetWindowId,
      delay: sendDelay
  )
  ```

  AFTER:
  ```swift
  // Check if embedded terminal is available (preferred)
  let bridge = EmbeddedTerminalBridge.shared

  if bridge.isAvailable {
      // Use embedded terminal (PTY dispatch)
      logInfo("Dispatching via embedded terminal", category: .execution)

      let dispatched = bridge.dispatchPrompt(content)
      guard dispatched else {
          throw TerminalServiceError.sendFailed
      }

      // Start embedded terminal monitoring for completion
      if let terminal = bridge.activeTerminal {
          stateMachine.startEmbeddedTerminalMonitoring(terminal: terminal)
      }
  } else {
      // Fall back to Terminal.app (AppleScript)
      logInfo("Dispatching via Terminal.app (fallback)", category: .execution)

      let isRunning = await terminalService.isTerminalRunning()
      if !isRunning {
          try await terminalService.launchTerminal()
      }

      try await terminalService.sendPrompt(
          content,
          toWindowId: targetWindowId,
          delay: sendDelay
      )
  }
  ```

  Also update the completion detection section (lines 494-502):

  BEFORE:
  ```swift
  // Start completion detection
  if useHooks {
      // Hook server will call handleHookCompletion when done
      // Also start polling as fallback
      stateMachine.startPolling(windowId: targetWindowId, interval: 2.0)
  } else {
      // Only use polling
      stateMachine.startPolling(windowId: targetWindowId, interval: 2.0)
  }
  ```

  AFTER:
  ```swift
  // Start completion detection (only for Terminal.app path)
  // Embedded terminal monitoring was already started above
  if !bridge.isAvailable {
      if useHooks {
          stateMachine.startPolling(windowId: targetWindowId, interval: 2.0)
      } else {
          stateMachine.startPolling(windowId: targetWindowId, interval: 2.0)
      }
  }
  ```

  This gives embedded terminal priority when available, with Terminal.app as fallback.
  </action>
  <verify>
  Build succeeds:
  ```bash
  xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build 2>&1 | tail -5
  ```

  Bridge integration in execute():
  ```bash
  grep -n "EmbeddedTerminalBridge" Dispatch/Services/ExecutionStateMachine.swift
  grep -n "bridge.dispatchPrompt" Dispatch/Services/ExecutionStateMachine.swift
  ```
  </verify>
  <done>
  ExecutionManager.execute() dispatches to embedded terminal when available.
  Falls back to Terminal.app/AppleScript when embedded terminal not open.
  </done>
</task>

</tasks>

<verification>
- Build succeeds without errors
- EmbeddedTerminalBridge.swift created with singleton, register/unregister/dispatchPrompt
- EmbeddedTerminalView registers coordinator with bridge
- ExecutionManager checks bridge first, falls back to TerminalService
- Embedded terminal monitoring started after PTY dispatch
</verification>

<success_criteria>
- EmbeddedTerminalBridge service exists and is a singleton
- Coordinator registers on terminal creation, unregisters on deinit
- ExecutionManager.execute() uses bridge.dispatchPrompt() when terminal available
- Falls back to TerminalService.sendPrompt() when no embedded terminal
- startEmbeddedTerminalMonitoring called after PTY dispatch
</success_criteria>

<output>
After completion, create `.planning/phases/17-claude-code-integration/17-04-SUMMARY.md`
</output>

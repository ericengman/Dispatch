---
phase: 17-claude-code-integration
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - Dispatch/Services/ClaudeCodeLauncher.swift
  - Dispatch/Views/Terminal/EmbeddedTerminalView.swift
  - Dispatch/Services/ExecutionStateMachine.swift
autonomous: true

must_haves:
  truths:
    - "Prompts sent to Claude Code via PTY arrive with trailing newline"
    - "Completion detected when Claude Code shows idle prompt pattern"
    - "Pattern matching works as fallback when HookServer unavailable"
    - "ExecutionStateMachine integrates with embedded terminal monitoring"
  artifacts:
    - path: "Dispatch/Services/ClaudeCodeLauncher.swift"
      provides: "Prompt dispatch and completion detection"
      contains: "dispatchPrompt"
    - path: "Dispatch/Views/Terminal/EmbeddedTerminalView.swift"
      provides: "Coordinator methods for prompt dispatch"
      contains: "dispatchPrompt"
    - path: "Dispatch/Services/ExecutionStateMachine.swift"
      provides: "Embedded terminal monitoring integration"
      contains: "startEmbeddedTerminalMonitoring"
  key_links:
    - from: "Dispatch/Views/Terminal/EmbeddedTerminalView.swift"
      to: "LocalProcessTerminalView"
      via: "terminal.send(txt:) for PTY write"
      pattern: "\\.send\\(txt:"
    - from: "Dispatch/Services/ExecutionStateMachine.swift"
      to: "Dispatch/Services/ClaudeCodeLauncher.swift"
      via: "Completion pattern checking"
      pattern: "isClaudeCodeIdle"
---

<objective>
Implement prompt dispatch via PTY and pattern-based completion detection for embedded terminal

Purpose: The core value of Dispatch is sending prompts to Claude Code. This plan wires up the PTY-based dispatch (replacing AppleScript) and adds pattern-based completion detection as a fallback/complement to HookServer.

Output: Working prompt dispatch and completion detection for embedded Claude Code sessions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-claude-code-integration/17-RESEARCH.md
@.planning/phases/17-claude-code-integration/17-01-SUMMARY.md
@Dispatch/Views/Terminal/EmbeddedTerminalView.swift
@Dispatch/Services/ClaudeCodeLauncher.swift
@Dispatch/Services/ExecutionStateMachine.swift
@Dispatch/Services/TerminalService.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add prompt dispatch to EmbeddedTerminalView.Coordinator</name>
  <files>Dispatch/Views/Terminal/EmbeddedTerminalView.swift</files>
  <action>
Extend the Coordinator class with prompt dispatch capability:

1. **Add dispatchPrompt method** to Coordinator:
```swift
/// Dispatch a prompt to Claude Code running in this terminal
/// - Parameter prompt: The prompt text to send
/// - Returns: true if prompt was sent, false if terminal unavailable
func dispatchPrompt(_ prompt: String) -> Bool {
    guard let terminal = terminalView else {
        logDebug("Cannot dispatch: no terminal view", category: .terminal)
        return false
    }

    // Prompts need newline to submit to Claude Code
    let fullPrompt = prompt.hasSuffix("\n") ? prompt : prompt + "\n"

    logInfo("Dispatching prompt (\(fullPrompt.count) chars)", category: .terminal)
    terminal.send(txt: fullPrompt)

    return true
}
```

2. **Keep the existing sendIfRunning method** for raw data sending (it's used differently)

3. **Add method to check if terminal is ready for dispatch**:
```swift
/// Check if terminal is ready to receive a prompt
var isReadyForDispatch: Bool {
    terminalView != nil
}
```

Note: The existing `sendIfRunning(_ data: Data)` sends raw bytes. `dispatchPrompt` sends text with automatic newline handling. Both are useful for different scenarios.
  </action>
  <verify>Build succeeds: `xcodebuild -scheme Dispatch build 2>&1 | tail -20`</verify>
  <done>Coordinator has dispatchPrompt method that sends text with trailing newline</done>
</task>

<task type="auto">
  <name>Task 2: Add completion pattern detection to ClaudeCodeLauncher</name>
  <files>Dispatch/Services/ClaudeCodeLauncher.swift</files>
  <action>
Add pattern-based completion detection to ClaudeCodeLauncher:

1. **Add completion patterns constant**:
```swift
/// Claude Code prompt patterns indicating idle state
private static let completionPatterns = [
    "╭─",     // Top-left corner of Claude prompt box
    "╰─",     // Bottom-left corner
    "> "      // Alternative simpler prompt
]
```

2. **Add isClaudeCodeIdle method**:
```swift
/// Check if Claude Code appears to be idle by examining terminal content
/// - Parameter terminal: The terminal to check
/// - Returns: true if Claude Code prompt pattern detected near end of buffer
func isClaudeCodeIdle(in terminal: LocalProcessTerminalView) -> Bool {
    let terminalInstance = terminal.getTerminal()

    // Get text from last few rows of visible buffer
    var recentText = ""
    let rows = terminalInstance.rows
    let buffer = terminalInstance.buffer
    let startRow = max(0, buffer.yBase + rows - 5)

    for row in startRow..<(buffer.yBase + rows) {
        if let line = buffer.lines[row] {
            recentText += line.translateToString() + "\n"
        }
    }

    // Check for patterns near end of recent content
    for pattern in Self.completionPatterns {
        if let range = recentText.range(of: pattern, options: .backwards) {
            let distance = recentText.distance(from: range.lowerBound, to: recentText.endIndex)
            if distance < 80 {
                logDebug("Claude Code idle detected (pattern: \(pattern))", category: .terminal)
                return true
            }
        }
    }

    return false
}
```

3. If SwiftTerm's buffer access API differs from the research, adjust accordingly:
   - Try `terminalInstance.getScrollInvariantText()` if available
   - Or iterate visible rows as shown above
   - The goal is to get the last ~200 chars of terminal content

4. Import SwiftTerm at the top if not already imported.
  </action>
  <verify>Build succeeds: `xcodebuild -scheme Dispatch build 2>&1 | tail -20`</verify>
  <done>ClaudeCodeLauncher has isClaudeCodeIdle method that checks terminal buffer for prompt patterns</done>
</task>

<task type="auto">
  <name>Task 3: Add embedded terminal monitoring to ExecutionStateMachine</name>
  <files>Dispatch/Services/ExecutionStateMachine.swift</files>
  <action>
Add support for monitoring embedded terminal completion alongside existing Terminal.app polling:

1. **Add new monitoring method** to ExecutionStateMachine:
```swift
/// Start completion monitoring for embedded terminal
/// Uses pattern matching as fallback/complement to HookServer
/// - Parameters:
///   - terminal: The embedded terminal to monitor
///   - interval: Polling interval in seconds (default 1.5s)
func startEmbeddedTerminalMonitoring(terminal: LocalProcessTerminalView, interval: TimeInterval = 1.5) {
    guard state == .executing else {
        logWarning("Cannot start monitoring from state: \(state)", category: .execution)
        return
    }

    logInfo("Starting embedded terminal completion monitoring (interval: \(interval)s)", category: .execution)

    pollingTask?.cancel()
    pollingTask = Task {
        while !Task.isCancelled && state == .executing {
            do {
                try await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))

                guard !Task.isCancelled else { break }

                // Check for completion pattern
                if ClaudeCodeLauncher.shared.isClaudeCodeIdle(in: terminal) {
                    logInfo("Completion detected via embedded terminal pattern", category: .execution)
                    await MainActor.run {
                        self.markCompleted(result: .success)
                    }
                    break
                }
            } catch {
                // Task cancelled or sleep interrupted
                break
            }
        }
    }
}
```

2. **Add import for SwiftTerm** at the top if not already present:
```swift
import SwiftTerm
```

3. **Note about HookServer integration**:
   - HookServer still calls `handleHookCompletion()` when stop hook fires
   - Pattern monitoring is a fallback that runs in parallel
   - First detection method to fire wins (markCompleted stops polling)
   - This dual approach ensures completion is detected even if hooks fail
  </action>
  <verify>Build succeeds: `xcodebuild -scheme Dispatch build 2>&1 | tail -20`</verify>
  <done>ExecutionStateMachine has startEmbeddedTerminalMonitoring method that uses pattern detection</done>
</task>

</tasks>

<verification>
1. EmbeddedTerminalView.Coordinator has dispatchPrompt method
2. ClaudeCodeLauncher has isClaudeCodeIdle pattern detection
3. ExecutionStateMachine has startEmbeddedTerminalMonitoring method
4. Build succeeds with no warnings
5. All methods properly integrate with existing infrastructure
</verification>

<success_criteria>
- dispatchPrompt sends text to PTY with trailing newline
- isClaudeCodeIdle checks terminal buffer for Claude Code prompt patterns
- startEmbeddedTerminalMonitoring polls terminal for completion
- Pattern detection works as fallback to HookServer
- Existing Terminal.app polling remains functional (not broken)
</success_criteria>

<output>
After completion, create `.planning/phases/17-claude-code-integration/17-02-SUMMARY.md`
</output>

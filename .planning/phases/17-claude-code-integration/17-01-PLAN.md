---
phase: 17-claude-code-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dispatch/Services/ClaudeCodeLauncher.swift
  - Dispatch/Views/Terminal/EmbeddedTerminalView.swift
autonomous: true

must_haves:
  truths:
    - "Claude Code launches in embedded terminal with colored output"
    - "Terminal environment includes PATH with claude CLI location"
    - "TERM/COLORTERM set correctly for 256-color and truecolor support"
    - "Claude Code process PID registered for lifecycle tracking"
  artifacts:
    - path: "Dispatch/Services/ClaudeCodeLauncher.swift"
      provides: "Claude Code environment configuration and launch"
      exports: ["ClaudeCodeLauncher"]
    - path: "Dispatch/Views/Terminal/EmbeddedTerminalView.swift"
      provides: "Integration with ClaudeCodeLauncher"
      contains: "launchClaudeCode"
  key_links:
    - from: "Dispatch/Views/Terminal/EmbeddedTerminalView.swift"
      to: "Dispatch/Services/ClaudeCodeLauncher.swift"
      via: "ClaudeCodeLauncher.shared.launchClaudeCode()"
      pattern: "ClaudeCodeLauncher\\.shared\\.launchClaudeCode"
    - from: "Dispatch/Services/ClaudeCodeLauncher.swift"
      to: "Dispatch/Services/TerminalProcessRegistry.swift"
      via: "PID registration after spawn"
      pattern: "TerminalProcessRegistry\\.shared\\.register"
---

<objective>
Create ClaudeCodeLauncher service to spawn Claude Code with proper terminal environment

Purpose: Claude Code requires specific environment variables (TERM, COLORTERM, PATH) to display colored output correctly and find the claude CLI. This plan creates the infrastructure to launch Claude Code directly in the embedded terminal.

Output: ClaudeCodeLauncher service that configures environment and spawns Claude Code process
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-claude-code-integration/17-RESEARCH.md
@Dispatch/Views/Terminal/EmbeddedTerminalView.swift
@Dispatch/Services/TerminalProcessRegistry.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClaudeCodeLauncher service</name>
  <files>Dispatch/Services/ClaudeCodeLauncher.swift</files>
  <action>
Create a new ClaudeCodeLauncher service with:

1. **Singleton pattern** - `static let shared = ClaudeCodeLauncher()`

2. **findClaudeCLI() -> String** method:
   - Check common paths in order: `~/.claude/local/bin/claude`, `/usr/local/bin/claude`, `/opt/homebrew/bin/claude`
   - Use FileManager.default.isExecutableFile(atPath:) to validate
   - Return "claude" as fallback to let PATH resolve it
   - Log which path was found

3. **buildEnvironment() -> [String]** method:
   - Start with SwiftTerm's Terminal.getEnvironmentVariables(termName: "xterm-256color", trueColor: true)
   - Inherit and extend PATH from ProcessInfo.processInfo.environment
   - Prepend `~/.claude/local/bin` and `/usr/local/bin` to PATH if not already present
   - Inherit these keys if present: HOME, USER, LOGNAME, SHELL, ANTHROPIC_API_KEY
   - Only add each key if not already in the environment array
   - Log the final PATH value

4. **launchClaudeCode(in terminal: LocalProcessTerminalView, workingDirectory: String?, skipPermissions: Bool = true)** method:
   - Get claude path from findClaudeCLI()
   - Build environment from buildEnvironment()
   - Build args array - add "--dangerously-skip-permissions" if skipPermissions is true
   - Call terminal.startProcess(executable: claudePath, args: args, environment: environment, execName: "claude")
   - Get PID via terminal.process.shellPid
   - If PID > 0, register with TerminalProcessRegistry.shared.register(pid:)
   - Log success with PID

Import SwiftTerm at the top. Use LoggingService for all logging (category: .terminal).
  </action>
  <verify>Build succeeds: `xcodebuild -scheme Dispatch build 2>&1 | tail -20`</verify>
  <done>ClaudeCodeLauncher.swift exists with findClaudeCLI, buildEnvironment, and launchClaudeCode methods</done>
</task>

<task type="auto">
  <name>Task 2: Add Claude Code launch option to EmbeddedTerminalView</name>
  <files>Dispatch/Views/Terminal/EmbeddedTerminalView.swift</files>
  <action>
Modify EmbeddedTerminalView to support launching Claude Code directly instead of just a shell:

1. **Add launch mode enum** at the top of the file (before the struct):
```swift
enum TerminalLaunchMode {
    case shell                    // Current behavior: launch user's shell
    case claudeCode(workingDirectory: String?, skipPermissions: Bool)
}
```

2. **Add property to struct**:
```swift
var launchMode: TerminalLaunchMode = .shell
```

3. **Modify makeNSView** to switch on launchMode:
   - For `.shell`: Keep existing behavior (startProcess with SHELL env var)
   - For `.claudeCode(let workingDir, let skipPermissions)`:
     - Call ClaudeCodeLauncher.shared.launchClaudeCode(in: terminal, workingDirectory: workingDir, skipPermissions: skipPermissions)
     - Note: ClaudeCodeLauncher handles PID registration, so don't double-register

4. **Adjust PID registration logic**:
   - Only register PID in makeNSView for `.shell` mode
   - For `.claudeCode` mode, ClaudeCodeLauncher handles registration
   - Keep the existing registration code but wrap it in a check for shell mode

The view should remain backward compatible - existing code that doesn't set launchMode will get the default `.shell` behavior.
  </action>
  <verify>Build succeeds: `xcodebuild -scheme Dispatch build 2>&1 | tail -20`</verify>
  <done>EmbeddedTerminalView supports both shell and Claude Code launch modes via launchMode property</done>
</task>

<task type="auto">
  <name>Task 3: Verify Claude Code launch with visual test</name>
  <files>Dispatch/Views/Terminal/EmbeddedTerminalView.swift</files>
  <action>
Temporarily modify ContentView or MainView (whichever hosts the terminal) to test Claude Code launch:

1. Find where EmbeddedTerminalView is instantiated
2. Temporarily change it to use Claude Code mode:
```swift
EmbeddedTerminalView(launchMode: .claudeCode(workingDirectory: nil, skipPermissions: true))
```

3. Build and run the app
4. Verify in the terminal panel:
   - Claude Code launches (shows initial animation/logo)
   - Colors display correctly (ANSI colors visible)
   - Box-drawing characters render properly (Unicode working)
5. Check console logs for:
   - "Claude Code started with PID X" message
   - No environment-related errors

6. After verification, REVERT the change back to `.shell` mode (or remove the explicit launchMode parameter) so the app returns to normal shell behavior. This was just a test.

Important: Do NOT leave the app launching Claude Code by default - revert to shell mode after testing.
  </action>
  <verify>App builds and runs, Claude Code can be launched manually, terminal shows colored output correctly</verify>
  <done>Claude Code launches with proper colors and PID is registered</done>
</task>

</tasks>

<verification>
1. ClaudeCodeLauncher service compiles and exports findClaudeCLI, buildEnvironment, launchClaudeCode
2. EmbeddedTerminalView supports TerminalLaunchMode enum with shell and claudeCode cases
3. Build succeeds with no warnings related to new code
4. Manual test confirms Claude Code launches with colored output
</verification>

<success_criteria>
- ClaudeCodeLauncher.swift exists in Dispatch/Services/
- EmbeddedTerminalView has launchMode property with TerminalLaunchMode enum
- Claude Code can be launched in embedded terminal with proper colors
- PID registration occurs when Claude Code is spawned
- Default behavior remains shell launch (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/17-claude-code-integration/17-01-SUMMARY.md`
</output>

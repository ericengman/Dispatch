---
phase: 15-safe-terminal-wrapper
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dispatch/Views/Terminal/EmbeddedTerminalView.swift
autonomous: true

must_haves:
  truths:
    - "Rapidly closing and reopening terminal views does not crash the app"
    - "Terminal continues receiving data during view updates/redraws"
    - "No EXC_BAD_ACCESS crashes during process termination"
  artifacts:
    - path: "Dispatch/Views/Terminal/EmbeddedTerminalView.swift"
      provides: "Safe NSViewRepresentable wrapper with lifecycle protection"
      contains: "deinit"
  key_links:
    - from: "Coordinator.deinit"
      to: "LocalProcessTerminalView.terminate()"
      via: "strong reference cleanup"
      pattern: "deinit.*terminate"
    - from: "Coordinator"
      to: "terminalView property"
      via: "strong reference retention"
      pattern: "var terminalView.*LocalProcessTerminalView"
---

<objective>
Implement safe terminal wrapper with SwiftUI lifecycle protection

Purpose: Prevent EXC_BAD_ACCESS crashes when terminal views are rapidly created/destroyed during SwiftUI view hierarchy updates. The current EmbeddedTerminalView lacks coordinator cleanup, allowing process callbacks to fire after deallocation.

Output: Updated EmbeddedTerminalView.swift with defensive lifecycle patterns from Phase 15 research.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-safe-terminal-wrapper/15-RESEARCH.md
@.planning/phases/14-swiftterm-integration/14-01-SUMMARY.md
@Dispatch/Views/Terminal/EmbeddedTerminalView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lifecycle-safe coordinator with deinit cleanup</name>
  <files>Dispatch/Views/Terminal/EmbeddedTerminalView.swift</files>
  <action>
Update the Coordinator class in EmbeddedTerminalView.swift with these changes:

1. Add strong reference to terminal view:
```swift
var terminalView: LocalProcessTerminalView?  // Strong reference for cleanup
```

2. Add deinit with proper cleanup:
```swift
deinit {
    logDebug("Coordinator deinit - terminating process", category: .terminal)
    terminalView?.terminate()
    terminalView = nil
}
```

3. In makeNSView, store reference in coordinator:
```swift
// After creating terminal, store reference for cleanup
context.coordinator.terminalView = terminal
```

This ensures process termination when SwiftUI recreates the view hierarchy, preventing callbacks to deallocated memory.
  </action>
  <verify>
Build succeeds:
```bash
xcodebuild -project Dispatch.xcodeproj -scheme Dispatch build 2>&1 | tail -5
```
Grep confirms deinit exists:
```bash
grep -n "deinit" Dispatch/Views/Terminal/EmbeddedTerminalView.swift
```
  </verify>
  <done>
Coordinator has terminalView property and deinit that calls terminate()
  </done>
</task>

<task type="auto">
  <name>Task 2: Add process.running guard for safe operations</name>
  <files>Dispatch/Views/Terminal/EmbeddedTerminalView.swift</files>
  <action>
Add a helper method to Coordinator for safe command sending (future-proofing for Phase 17):

```swift
/// Safely send data to terminal, checking process state first
func sendIfRunning(_ data: Data) -> Bool {
    guard let terminal = terminalView else {
        logDebug("Cannot send: no terminal view", category: .terminal)
        return false
    }
    // LocalProcessTerminalView.process is internal, but we can check via getProcess()
    // Actually, LocalProcessTerminalView doesn't expose process directly
    // The safe pattern is to catch the error in logging
    logDebug("Sending \(data.count) bytes to terminal", category: .terminal)
    terminal.send(txt: String(data: data, encoding: .utf8) ?? "")
    return true
}

/// Check if terminal is available for commands
var isTerminalActive: Bool {
    terminalView != nil
}
```

Also update processTerminated to clear the reference:
```swift
func processTerminated(source _: TerminalView, exitCode: Int32?) {
    logDebug("Terminal process exited with code: \(exitCode ?? -1)", category: .terminal)
    // Clear reference since process is gone
    terminalView = nil
    DispatchQueue.main.async {
        self.onProcessExit?(exitCode)
    }
}
```

Note: LocalProcessTerminalView doesn't directly expose the running state of its process, but clearing the reference on termination and using deinit cleanup addresses the safety concerns.
  </action>
  <verify>
Build succeeds:
```bash
xcodebuild -project Dispatch.xcodeproj -scheme Dispatch build 2>&1 | tail -5
```
New methods exist:
```bash
grep -n "sendIfRunning\|isTerminalActive" Dispatch/Views/Terminal/EmbeddedTerminalView.swift
```
  </verify>
  <done>
Coordinator has sendIfRunning helper and isTerminalActive property, processTerminated clears reference
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
```bash
xcodebuild -project Dispatch.xcodeproj -scheme Dispatch build
```
Expected: BUILD SUCCEEDED

2. Code structure verification:
```bash
grep -A3 "deinit" Dispatch/Views/Terminal/EmbeddedTerminalView.swift
```
Expected: Shows terminate() call in deinit

3. Manual stress test (optional but recommended):
- Build and run app
- Press Cmd+Shift+T rapidly 20+ times
- App should not crash
- Terminal should start fresh each time it's shown
</verification>

<success_criteria>
- [ ] Build succeeds with no errors
- [ ] Coordinator has `terminalView: LocalProcessTerminalView?` property
- [ ] Coordinator has `deinit` that calls `terminalView?.terminate()`
- [ ] makeNSView stores terminal reference in coordinator
- [ ] processTerminated clears the terminalView reference
- [ ] Coordinator has sendIfRunning helper for future use
- [ ] Rapid toggle stress test does not crash (manual verification)
</success_criteria>

<output>
After completion, create `.planning/phases/15-safe-terminal-wrapper/15-01-SUMMARY.md`
</output>

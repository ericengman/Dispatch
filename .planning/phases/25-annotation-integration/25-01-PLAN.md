---
phase: 25-annotation-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dispatch/Models/QuickCapture.swift
  - Dispatch/Models/AnnotationTypes.swift
  - Dispatch/Views/QuickCapture/QuickCaptureAnnotationView.swift
  - Dispatch/Services/CaptureCoordinator.swift
  - Dispatch/Views/MainView.swift
  - Dispatch/DispatchApp.swift
autonomous: true

must_haves:
  truths:
    - "After capture, annotation UI opens automatically with the screenshot"
    - "User can capture additional screenshots while annotation UI is open"
    - "User can markup captured screenshots with arrows, boxes, and text before dispatch"
  artifacts:
    - path: "Dispatch/Models/QuickCapture.swift"
      provides: "Hashable + Codable model for WindowGroup identity"
      contains: "struct QuickCapture: Hashable, Codable, Identifiable"
    - path: "Dispatch/Models/AnnotationTypes.swift"
      provides: "Extended AnnotatedImage with QuickCapture initializer"
      contains: "init(quickCapture:"
    - path: "Dispatch/Services/CaptureCoordinator.swift"
      provides: "Coordinates capture results and window opening"
      contains: "class CaptureCoordinator"
    - path: "Dispatch/Views/QuickCapture/QuickCaptureAnnotationView.swift"
      provides: "Annotation UI for quick captures"
      min_lines: 100
    - path: "Dispatch/DispatchApp.swift"
      provides: "Value-based WindowGroup for QuickCapture"
      contains: "WindowGroup.*for: QuickCapture.self"
  key_links:
    - from: "DispatchApp.swift Capture menu"
      to: "CaptureCoordinator.handleCaptureResult"
      via: "shared singleton call"
      pattern: "CaptureCoordinator\\.shared\\.handleCaptureResult"
    - from: "MainView.swift"
      to: "openWindow(value: QuickCapture)"
      via: "onChange observer on pendingCapture"
      pattern: "onChange.*pendingCapture.*openWindow"
    - from: "QuickCaptureAnnotationView"
      to: "AnnotationCanvasView + AnnotationToolbar"
      via: "view composition"
      pattern: "AnnotationCanvasView"
---

<objective>
Connect capture pipeline to annotation UI with auto-opening window.

Purpose: When user captures a region or window, the annotation UI should open automatically with the screenshot loaded, ready for markup.

Output:
- QuickCapture model for WindowGroup identity
- Extended AnnotatedImage with QuickCapture-compatible initializer
- CaptureCoordinator service for capture-to-window coordination
- Value-based WindowGroup for annotation windows
- QuickCaptureAnnotationView reusing existing annotation infrastructure
- Capture menu wired to open annotation windows
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-annotation-integration/25-RESEARCH.md
@Dispatch/Services/ScreenshotCaptureService.swift
@Dispatch/Views/Simulator/AnnotationWindow.swift
@Dispatch/ViewModels/SimulatorViewModel.swift
@Dispatch/Models/AnnotationTypes.swift
@Dispatch/DispatchApp.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: QuickCapture Model, AnnotatedImage Extension, and Value-Based WindowGroup</name>
  <files>
    Dispatch/Models/QuickCapture.swift
    Dispatch/Models/AnnotationTypes.swift
    Dispatch/DispatchApp.swift
  </files>
  <action>
Create QuickCapture model and extend AnnotatedImage for QuickCapture compatibility.

1. Create `Dispatch/Models/QuickCapture.swift`:
```swift
import AppKit
import Foundation

/// Lightweight model for screenshots captured outside of SimulatorRun context.
/// Hashable + Codable for value-based WindowGroup identity.
struct QuickCapture: Hashable, Codable, Identifiable {
    let id: UUID
    let filePath: String
    let timestamp: Date
    var label: String?

    init(fileURL: URL) {
        self.id = UUID()
        self.filePath = fileURL.path
        self.timestamp = Date()
        self.label = nil
    }

    var fileURL: URL {
        URL(fileURLWithPath: filePath)
    }

    var image: NSImage? {
        NSImage(contentsOfFile: filePath)
    }

    // Hash on id only for unique window identity
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

    static func == (lhs: QuickCapture, rhs: QuickCapture) -> Bool {
        lhs.id == rhs.id
    }
}
```

2. Extend `Dispatch/Models/AnnotationTypes.swift` to add QuickCapture-compatible initializer.

IMPORTANT API COMPATIBILITY: The existing AnnotatedImage struct requires a Screenshot object:
```swift
struct AnnotatedImage: Identifiable, Sendable {
    let id: UUID
    let screenshot: Screenshot  // @Model SwiftData class
    var annotations: [Annotation]
    var cropRect: CGRect?
}
```

Since Screenshot is a SwiftData @Model that requires persistence context, we need to extend AnnotatedImage with an alternative storage mechanism for QuickCapture scenarios. Add after the existing struct:

```swift
// MARK: - QuickCapture Support

extension AnnotatedImage {
    /// Alternative storage for QuickCapture (non-SwiftData) images.
    /// Uses filePath directly when Screenshot is not available.
    private static var quickCaptureImages: [UUID: (filePath: String, image: NSImage)] = [:]

    /// Creates an AnnotatedImage from a QuickCapture (no Screenshot required).
    /// Stores the image data separately since we can't use SwiftData outside the model context.
    init(quickCapture: QuickCapture) {
        // Create a minimal Screenshot-like wrapper using dummy values
        // The actual image is retrieved from quickCaptureImages cache
        self.id = quickCapture.id

        // Store the image in static cache for later retrieval
        if let image = quickCapture.image {
            Self.quickCaptureImages[quickCapture.id] = (quickCapture.filePath, image)
        }

        // We need a Screenshot object for the existing API, but we'll create a detached one
        // Note: This Screenshot is NOT persisted to SwiftData - it's purely for API compatibility
        self.screenshot = Screenshot(
            id: quickCapture.id,
            filePath: quickCapture.filePath,
            captureIndex: 0,
            label: quickCapture.label
        )
        self.annotations = []
        self.cropRect = nil
    }

    /// Retrieves the cached image for QuickCapture-based AnnotatedImages.
    /// Falls back to screenshot.image for Screenshot-based AnnotatedImages.
    var resolvedImage: NSImage? {
        if let cached = Self.quickCaptureImages[id] {
            return cached.image
        }
        return screenshot.image
    }

    /// Cleans up cached QuickCapture image data when no longer needed.
    static func cleanupQuickCapture(id: UUID) {
        quickCaptureImages.removeValue(forKey: id)
    }
}
```

3. Update `DispatchApp.swift` to add value-based WindowGroup:
- Add new WindowGroup AFTER the Settings scene:
```swift
// QuickCapture annotation window
WindowGroup("Annotate Screenshot", for: QuickCapture.self) { $capture in
    if let capture = capture {
        QuickCaptureAnnotationView(capture: capture)
            .frame(minWidth: 1000, minHeight: 700)
    }
}
.defaultSize(width: 1200, height: 800)
```

Note: The view will be created in Task 2.
  </action>
  <verify>
Project builds without errors: `xcodebuild -scheme Dispatch build`
Verify AnnotatedImage extension exists: `grep -n "init(quickCapture:" Dispatch/Models/AnnotationTypes.swift`
  </verify>
  <done>
QuickCapture model exists with Hashable + Codable conformance.
AnnotatedImage extended with QuickCapture-compatible initializer.
WindowGroup registered in DispatchApp.
  </done>
</task>

<task type="auto">
  <name>Task 2: CaptureCoordinator Service and QuickCaptureAnnotationView</name>
  <files>
    Dispatch/Services/CaptureCoordinator.swift
    Dispatch/Views/QuickCapture/QuickCaptureAnnotationView.swift
    Dispatch/Views/MainView.swift
    Dispatch/DispatchApp.swift
  </files>
  <action>
Create CaptureCoordinator service, annotation view, and wire capture completion to open annotation window.

1. Create `Dispatch/Services/CaptureCoordinator.swift`:
```swift
import Foundation

/// Coordinates capture results and window opening.
/// Uses @Published pendingCapture which MainView observes to trigger openWindow.
@MainActor
final class CaptureCoordinator: ObservableObject {
    static let shared = CaptureCoordinator()

    @Published var pendingCapture: QuickCapture?

    private init() {}

    func handleCaptureResult(_ result: CaptureResult) {
        switch result {
        case .success(let url):
            guard FileManager.default.fileExists(atPath: url.path) else {
                logError("Capture file not found: \(url.path)", category: .capture)
                return
            }
            pendingCapture = QuickCapture(fileURL: url)
            logInfo("Capture ready for annotation: \(url.lastPathComponent)", category: .capture)

        case .cancelled:
            logInfo("Capture cancelled by user", category: .capture)

        case .error(let error):
            logError("Capture failed: \(error)", category: .capture)
        }
    }
}
```

2. Create directory `Dispatch/Views/QuickCapture/` if needed.

3. Create `Dispatch/Views/QuickCapture/QuickCaptureAnnotationView.swift`:

IMPORTANT API COMPATIBILITY: Use the verified AnnotationViewModel API:
- `loadAnnotatedImage(_ image: AnnotatedImage)` - exists at line 316-319 in SimulatorViewModel.swift
- Create AnnotatedImage using the new `init(quickCapture:)` initializer from Task 1

```swift
import SwiftUI

/// Annotation view for QuickCapture screenshots.
/// Reuses existing annotation infrastructure (AnnotationCanvasView, AnnotationToolbar).
struct QuickCaptureAnnotationView: View {
    let capture: QuickCapture

    @StateObject private var annotationVM = AnnotationViewModel()
    @State private var showingError = false
    @State private var errorMessage: String?
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack(spacing: 0) {
            HSplitView {
                // Left: Canvas and toolbar (reuse existing)
                leftPanel
                    .frame(minWidth: 600)

                // Right: Queue, prompt, and dispatch
                rightPanel
                    .frame(minWidth: 280, maxWidth: 350)
            }
        }
        .background(Color(nsColor: .windowBackgroundColor))
        .alert("Error", isPresented: $showingError) {
            Button("OK", role: .cancel) { errorMessage = nil }
        } message: {
            Text(errorMessage ?? "Unknown error")
        }
        .onAppear {
            loadCapture()
        }
        .onKeyPress(keys: [.escape]) { _ in
            dismiss()
            return .handled
        }
        .onDisappear {
            // Cleanup cached image data
            AnnotatedImage.cleanupQuickCapture(id: capture.id)
        }
    }

    private var leftPanel: some View {
        VStack(spacing: 0) {
            AnnotationCanvasView()
                .environmentObject(annotationVM)

            Divider()

            AnnotationToolbar()
                .environmentObject(annotationVM)
        }
    }

    private var rightPanel: some View {
        VStack(spacing: 0) {
            // Send queue header
            HStack {
                Label("Send Queue", systemImage: "tray.and.arrow.up")
                    .font(.headline)
                Spacer()
                Text("\(annotationVM.queueCount)/5")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            .padding()

            // Send queue
            SendQueueView()
                .environmentObject(annotationVM)
                .frame(height: 120)

            Divider()

            // Prompt input
            promptSection

            Spacer()

            // Placeholder for session picker (added in 25-02)
            Text("Session selection coming in next plan")
                .font(.caption)
                .foregroundStyle(.tertiary)
                .padding()

            Divider()

            // Dispatch button (disabled until 25-02 adds session picker)
            dispatchButton
                .padding()
        }
        .background(Color(nsColor: .controlBackgroundColor).opacity(0.5))
    }

    private var promptSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Prompt")
                .font(.headline)

            TextEditor(text: $annotationVM.promptText)
                .font(.body)
                .frame(minHeight: 100)
                .scrollContentBackground(.hidden)
                .background(Color(nsColor: .textBackgroundColor))
                .clipShape(RoundedRectangle(cornerRadius: 8))
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .strokeBorder(Color.secondary.opacity(0.3), lineWidth: 1)
                )
        }
        .padding()
    }

    private var dispatchButton: some View {
        Button {
            // Dispatch implemented in 25-02
        } label: {
            HStack(spacing: 6) {
                Image(systemName: "paperplane.fill")
                Text("Dispatch to Session")
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
        }
        .buttonStyle(.borderedProminent)
        .disabled(true) // Enabled in 25-02 with session picker
        .keyboardShortcut(.return, modifiers: .command)
    }

    private func loadCapture() {
        // Verify image exists before proceeding
        guard capture.image != nil else {
            errorMessage = "Failed to load screenshot from: \(capture.filePath)"
            showingError = true
            logError("Failed to load QuickCapture image: \(capture.filePath)", category: .capture)
            return
        }

        // Create AnnotatedImage using the QuickCapture-compatible initializer
        // This uses the extension added in Task 1 that handles non-SwiftData images
        let annotatedImage = AnnotatedImage(quickCapture: capture)

        // Load into AnnotationViewModel using existing API
        // Verified: loadAnnotatedImage(_ image: AnnotatedImage) exists at SimulatorViewModel.swift:316-319
        annotationVM.loadAnnotatedImage(annotatedImage)

        logInfo("Loaded QuickCapture into annotation view: \(capture.fileURL.lastPathComponent)", category: .capture)
    }
}
```

4. Update `Dispatch/Views/MainView.swift` to observe CaptureCoordinator and open windows:
- Add `@ObservedObject private var captureCoordinator = CaptureCoordinator.shared`
- Add `@Environment(\.openWindow) private var openWindow`
- Add onChange handler in body:
```swift
.onChange(of: captureCoordinator.pendingCapture) { oldValue, newValue in
    if let capture = newValue {
        openWindow(value: capture)
        captureCoordinator.pendingCapture = nil
    }
}
```

5. Update `DispatchApp.swift` Capture menu to use coordinator:
```swift
Button("Capture Region") {
    Task {
        let result = await ScreenshotCaptureService.shared.captureRegion()
        CaptureCoordinator.shared.handleCaptureResult(result)
    }
}

Button("Capture Window") {
    Task {
        let result = await ScreenshotCaptureService.shared.captureWindow()
        CaptureCoordinator.shared.handleCaptureResult(result)
    }
}
```
  </action>
  <verify>
1. Build succeeds: `xcodebuild -scheme Dispatch build`
2. Grep confirms CaptureCoordinator wiring: `grep -n "pendingCapture" Dispatch/Views/MainView.swift` shows onChange handler
3. Grep confirms openWindow call: `grep -n "openWindow.*value" Dispatch/Views/MainView.swift` shows openWindow(value: capture)
4. Grep confirms QuickCapture initializer usage: `grep -n "AnnotatedImage(quickCapture:" Dispatch/Views/QuickCapture/QuickCaptureAnnotationView.swift`
5. Launch app, Cmd+Shift+6 opens region capture
6. After selecting region, verify pendingCapture is set (log message: "Capture ready for annotation")
7. Verify annotation window opens (log message: "Loaded QuickCapture into annotation view")
8. Verify pendingCapture is cleared after window opens (no stale state)
9. Cmd+Shift+7 opens window capture, after capture annotation window opens
10. Annotation tools work (arrows, rectangles, text) - select tool, draw on canvas
  </verify>
  <done>
CaptureCoordinator service created with pendingCapture published property.
MainView observes pendingCapture and calls openWindow(value: capture), then clears pendingCapture.
QuickCaptureAnnotationView exists and uses AnnotatedImage(quickCapture:) for API compatibility.
Capture menu triggers CaptureCoordinator.handleCaptureResult after successful capture.
User can annotate captured screenshots with existing tools.
  </done>
</task>

</tasks>

<verification>
1. Build verification: `xcodebuild -scheme Dispatch build` succeeds
2. Capture Region (Cmd+Shift+6) opens annotation window after capture
3. Capture Window (Cmd+Shift+7) opens annotation window after capture
4. Multiple captures open multiple windows: Start first capture, open annotation window, then start second capture while first window is open. Verify both annotation windows exist simultaneously (value-based WindowGroup creates separate windows per QuickCapture id).
5. Annotation tools (crop, arrow, rectangle, freehand, text) work on captured screenshots
6. Queue shows images added after annotation
</verification>

<success_criteria>
- QuickCapture model with Hashable + Codable conformance
- AnnotatedImage extended with QuickCapture-compatible initializer
- CaptureCoordinator service with pendingCapture observable property
- Value-based WindowGroup registered in DispatchApp
- MainView wired to observe pendingCapture and open annotation windows
- QuickCaptureAnnotationView renders and accepts user annotations
- Capture completion triggers automatic window opening via coordinator
- Multiple captures can open multiple annotation windows simultaneously
- Existing annotation infrastructure reused (no duplication)
</success_criteria>

<output>
After completion, create `.planning/phases/25-annotation-integration/25-01-SUMMARY.md`
</output>

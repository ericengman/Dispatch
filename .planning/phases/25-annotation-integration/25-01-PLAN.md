---
phase: 25-annotation-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dispatch/Models/QuickCapture.swift
  - Dispatch/Views/QuickCapture/QuickCaptureAnnotationView.swift
  - Dispatch/DispatchApp.swift
autonomous: true

must_haves:
  truths:
    - "After capture, annotation UI opens automatically with the screenshot"
    - "User can capture additional screenshots while annotation UI is open"
    - "Existing annotation tools (arrows, boxes, text) work on captured screenshots"
  artifacts:
    - path: "Dispatch/Models/QuickCapture.swift"
      provides: "Hashable + Codable model for WindowGroup identity"
      contains: "struct QuickCapture: Hashable, Codable, Identifiable"
    - path: "Dispatch/Views/QuickCapture/QuickCaptureAnnotationView.swift"
      provides: "Annotation UI for quick captures"
      min_lines: 100
    - path: "Dispatch/DispatchApp.swift"
      provides: "Value-based WindowGroup for QuickCapture"
      contains: "WindowGroup.*for: QuickCapture.self"
  key_links:
    - from: "DispatchApp.swift Capture menu"
      to: "openWindow(value: QuickCapture)"
      via: "handleCaptureResult closure"
      pattern: "openWindow.*value.*capture"
    - from: "QuickCaptureAnnotationView"
      to: "AnnotationCanvasView + AnnotationToolbar"
      via: "view composition"
      pattern: "AnnotationCanvasView"
---

<objective>
Connect capture pipeline to annotation UI with auto-opening window.

Purpose: When user captures a region or window, the annotation UI should open automatically with the screenshot loaded, ready for markup.

Output:
- QuickCapture model for WindowGroup identity
- Value-based WindowGroup for annotation windows
- QuickCaptureAnnotationView reusing existing annotation infrastructure
- Capture menu wired to open annotation windows
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-annotation-integration/25-RESEARCH.md
@Dispatch/Services/ScreenshotCaptureService.swift
@Dispatch/Views/Simulator/AnnotationWindow.swift
@Dispatch/ViewModels/SimulatorViewModel.swift
@Dispatch/DispatchApp.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: QuickCapture Model and Value-Based WindowGroup</name>
  <files>
    Dispatch/Models/QuickCapture.swift
    Dispatch/DispatchApp.swift
  </files>
  <action>
Create QuickCapture model following patterns from RESEARCH.md:

1. Create `Dispatch/Models/QuickCapture.swift`:
```swift
/// Lightweight model for screenshots captured outside of SimulatorRun context.
/// Hashable + Codable for value-based WindowGroup identity.
struct QuickCapture: Hashable, Codable, Identifiable {
    let id: UUID
    let filePath: String
    let timestamp: Date
    var label: String?

    init(fileURL: URL) {
        self.id = UUID()
        self.filePath = fileURL.path
        self.timestamp = Date()
        self.label = nil
    }

    var fileURL: URL {
        URL(fileURLWithPath: filePath)
    }

    var image: NSImage? {
        NSImage(contentsOfFile: filePath)
    }

    // Hash on id only for unique window identity
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

    static func == (lhs: QuickCapture, rhs: QuickCapture) -> Bool {
        lhs.id == rhs.id
    }
}
```

2. Update `DispatchApp.swift` to add value-based WindowGroup:
- Add new WindowGroup AFTER the Settings scene:
```swift
// QuickCapture annotation window
WindowGroup("Annotate Screenshot", for: QuickCapture.self) { $capture in
    if let capture = capture {
        QuickCaptureAnnotationView(capture: capture)
            .frame(minWidth: 1000, minHeight: 700)
    }
}
.defaultSize(width: 1200, height: 800)
```

Note: Import Foundation and AppKit at top of QuickCapture.swift. The view will be created in Task 2.
  </action>
  <verify>
Project builds without errors: `xcodebuild -scheme Dispatch build`
  </verify>
  <done>
QuickCapture model exists with Hashable + Codable conformance, WindowGroup registered in DispatchApp.
  </done>
</task>

<task type="auto">
  <name>Task 2: QuickCaptureAnnotationView with Auto-Open Wiring</name>
  <files>
    Dispatch/Views/QuickCapture/QuickCaptureAnnotationView.swift
    Dispatch/DispatchApp.swift
  </files>
  <action>
Create annotation view for quick captures and wire capture completion to open it.

1. Create directory `Dispatch/Views/QuickCapture/` if needed.

2. Create `Dispatch/Views/QuickCapture/QuickCaptureAnnotationView.swift`:
```swift
/// Annotation view for QuickCapture screenshots.
/// Reuses existing annotation infrastructure (AnnotationCanvasView, AnnotationToolbar).
struct QuickCaptureAnnotationView: View {
    let capture: QuickCapture

    @StateObject private var annotationVM = AnnotationViewModel()
    @State private var showingError = false
    @State private var errorMessage: String?
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack(spacing: 0) {
            HSplitView {
                // Left: Canvas and toolbar (reuse existing)
                leftPanel
                    .frame(minWidth: 600)

                // Right: Queue, prompt, and dispatch
                rightPanel
                    .frame(minWidth: 280, maxWidth: 350)
            }
        }
        .background(Color(nsColor: .windowBackgroundColor))
        .alert("Error", isPresented: $showingError) {
            Button("OK", role: .cancel) { errorMessage = nil }
        } message: {
            Text(errorMessage ?? "Unknown error")
        }
        .onAppear {
            loadCapture()
        }
        .onKeyPress(keys: [.escape]) { _ in
            dismiss()
            return .handled
        }
    }

    private var leftPanel: some View {
        VStack(spacing: 0) {
            AnnotationCanvasView()
                .environmentObject(annotationVM)

            Divider()

            AnnotationToolbar()
                .environmentObject(annotationVM)
        }
    }

    private var rightPanel: some View {
        VStack(spacing: 0) {
            // Send queue header
            HStack {
                Label("Send Queue", systemImage: "tray.and.arrow.up")
                    .font(.headline)
                Spacer()
                Text("\(annotationVM.queueCount)/5")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            .padding()

            // Send queue
            SendQueueView()
                .environmentObject(annotationVM)
                .frame(height: 120)

            Divider()

            // Prompt input
            promptSection

            Spacer()

            // Placeholder for session picker (added in 25-02)
            Text("Session selection coming in next plan")
                .font(.caption)
                .foregroundStyle(.tertiary)
                .padding()

            Divider()

            // Dispatch button (disabled until 25-02 adds session picker)
            dispatchButton
                .padding()
        }
        .background(Color(nsColor: .controlBackgroundColor).opacity(0.5))
    }

    private var promptSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Prompt")
                .font(.headline)

            TextEditor(text: $annotationVM.promptText)
                .font(.body)
                .frame(minHeight: 100)
                .scrollContentBackground(.hidden)
                .background(Color(nsColor: .textBackgroundColor))
                .clipShape(RoundedRectangle(cornerRadius: 8))
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .strokeBorder(Color.secondary.opacity(0.3), lineWidth: 1)
                )
        }
        .padding()
    }

    private var dispatchButton: some View {
        Button {
            // Dispatch implemented in 25-02
        } label: {
            HStack(spacing: 6) {
                Image(systemName: "paperplane.fill")
                Text("Dispatch to Session")
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
        }
        .buttonStyle(.borderedProminent)
        .disabled(true) // Enabled in 25-02 with session picker
        .keyboardShortcut(.return, modifiers: .command)
    }

    private func loadCapture() {
        // Create Screenshot-compatible object for AnnotationViewModel
        guard let image = capture.image else {
            errorMessage = "Failed to load screenshot"
            showingError = true
            logError("Failed to load QuickCapture image: \(capture.filePath)", category: .capture)
            return
        }

        // Create AnnotatedImage directly from the capture
        let annotatedImage = AnnotatedImage(
            id: capture.id,
            originalImage: image,
            screenshotId: capture.id,
            filePath: capture.filePath
        )
        annotationVM.loadAnnotatedImage(annotatedImage)

        logInfo("Loaded QuickCapture into annotation view: \(capture.fileURL.lastPathComponent)", category: .capture)
    }
}
```

3. Update `DispatchApp.swift` Capture menu handlers to open annotation window:
- Add `@Environment(\.openWindow) private var openWindow` to a new CaptureMenuHandler helper, OR
- Use NotificationCenter pattern like existing menus (simpler for CommandMenu context)

Since CommandMenu can't directly access @Environment, use a shared state approach:

Add to DispatchApp:
```swift
@StateObject private var captureCoordinator = CaptureCoordinator.shared
```

Create `Dispatch/Services/CaptureCoordinator.swift`:
```swift
/// Coordinates capture results and window opening
@MainActor
final class CaptureCoordinator: ObservableObject {
    static let shared = CaptureCoordinator()

    @Published var pendingCapture: QuickCapture?

    private init() {}

    func handleCaptureResult(_ result: CaptureResult) {
        switch result {
        case .success(let url):
            guard FileManager.default.fileExists(atPath: url.path) else {
                logError("Capture file not found: \(url.path)", category: .capture)
                return
            }
            pendingCapture = QuickCapture(fileURL: url)
            logInfo("Capture ready for annotation: \(url.lastPathComponent)", category: .capture)

        case .cancelled:
            logInfo("Capture cancelled by user", category: .capture)

        case .error(let error):
            logError("Capture failed: \(error)", category: .capture)
        }
    }
}
```

Update MainView to observe and open window:
```swift
// In MainView body, add:
.onChange(of: captureCoordinator.pendingCapture) { oldValue, newValue in
    if let capture = newValue {
        openWindow(value: capture)
        captureCoordinator.pendingCapture = nil
    }
}
```

Update Capture menu to use coordinator:
```swift
Button("Capture Region") {
    Task {
        let result = await ScreenshotCaptureService.shared.captureRegion()
        CaptureCoordinator.shared.handleCaptureResult(result)
    }
}

Button("Capture Window") {
    Task {
        let result = await ScreenshotCaptureService.shared.captureWindow()
        CaptureCoordinator.shared.handleCaptureResult(result)
    }
}
```
  </action>
  <verify>
1. Build succeeds: `xcodebuild -scheme Dispatch build`
2. Launch app, Cmd+Shift+6 opens region capture
3. After selecting region, annotation window opens with screenshot
4. Cmd+Shift+7 opens window capture, after capture annotation window opens
5. Annotation tools work (arrows, rectangles, text)
  </verify>
  <done>
QuickCaptureAnnotationView exists and reuses existing annotation infrastructure.
Capture menu triggers open annotation window after successful capture.
User can annotate captured screenshots with existing tools.
  </done>
</task>

</tasks>

<verification>
1. Build verification: `xcodebuild -scheme Dispatch build` succeeds
2. Capture Region (Cmd+Shift+6) opens annotation window after capture
3. Capture Window (Cmd+Shift+7) opens annotation window after capture
4. Multiple captures open multiple windows (value-based WindowGroup)
5. Annotation tools (crop, arrow, rectangle, freehand, text) work on captured screenshots
6. Queue shows images added after annotation
</verification>

<success_criteria>
- QuickCapture model with Hashable + Codable conformance
- Value-based WindowGroup registered in DispatchApp
- QuickCaptureAnnotationView renders and accepts user annotations
- Capture completion triggers automatic window opening
- Existing annotation infrastructure reused (no duplication)
</success_criteria>

<output>
After completion, create `.planning/phases/25-annotation-integration/25-01-SUMMARY.md`
</output>

---
phase: 19-session-persistence
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - Dispatch/Views/Terminal/MultiSessionTerminalView.swift
  - Dispatch/Services/TerminalSessionManager.swift
autonomous: true

must_haves:
  truths:
    - "Reopening Dispatch offers to resume previous sessions from SwiftData"
    - "Resuming a session uses claude -r <sessionId> to continue conversation"
    - "Expired/stale sessions create fresh sessions gracefully"
    - "Sessions are auto-associated with Projects by matching workingDirectory to Project.path"
  artifacts:
    - path: "Dispatch/Views/Terminal/MultiSessionTerminalView.swift"
      provides: "Load persisted sessions on launch, show resume picker"
      contains: "persistedSessions"
    - path: "Dispatch/Services/TerminalSessionManager.swift"
      provides: "loadPersistedSessions and project association methods"
      contains: "loadPersistedSessions"
  key_links:
    - from: "Dispatch/Views/Terminal/MultiSessionTerminalView.swift"
      to: "TerminalSessionManager"
      via: "loadPersistedSessions on appear"
      pattern: "loadPersistedSessions"
    - from: "Dispatch/Services/TerminalSessionManager.swift"
      to: "Project"
      via: "path matching for auto-association"
      pattern: "project.*path.*workingDirectory"
---

<objective>
Wire session persistence: load on launch, resume picker, stale handling, project association

Purpose: Complete session persistence by loading persisted sessions on app launch, offering resume picker, handling stale sessions gracefully (PERS-04, PERS-05), and auto-associating sessions with Projects.

Output: Full session persistence flow - sessions survive app restart, user can resume or start fresh, stale sessions fall back to fresh.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-session-persistence/19-RESEARCH.md
@.planning/phases/19-session-persistence/19-01-SUMMARY.md

# Files to modify
@Dispatch/Views/Terminal/MultiSessionTerminalView.swift
@Dispatch/Services/TerminalSessionManager.swift

# Reference for patterns
@Dispatch/Models/TerminalSession.swift
@Dispatch/Services/ClaudeSessionDiscoveryService.swift
@Dispatch/Views/Terminal/SessionResumePicker.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add session loading and project association to TerminalSessionManager</name>
  <files>
    Dispatch/Services/TerminalSessionManager.swift
  </files>
  <action>
Add methods to TerminalSessionManager for loading persisted sessions and associating with projects:

1. Add method to load persisted sessions from SwiftData:
   ```swift
   /// Load persisted sessions from SwiftData on app launch
   /// Returns sessions sorted by lastActivity (most recent first)
   func loadPersistedSessions() -> [TerminalSession] {
       guard let modelContext = modelContext else {
           logWarning("Cannot load sessions: modelContext not configured", category: .terminal)
           return []
       }

       var descriptor = FetchDescriptor<TerminalSession>(
           sortBy: [SortDescriptor(\.lastActivity, order: .reverse)]
       )
       // Limit to sessions from last 7 days
       let cutoff = Date().addingTimeInterval(-7 * 24 * 3600)
       descriptor.predicate = #Predicate { $0.lastActivity > cutoff }

       do {
           let sessions = try modelContext.fetch(descriptor)
           logInfo("Loaded \(sessions.count) persisted sessions", category: .terminal)
           return sessions
       } catch {
           logError("Failed to load persisted sessions: \(error)", category: .terminal)
           return []
       }
   }
   ```

2. Add method to associate session with project by path matching:
   ```swift
   /// Associate session with Project by matching workingDirectory to Project.path
   /// - Parameter session: The session to associate
   /// - Returns: The associated Project, if found
   @discardableResult
   func associateWithProject(_ session: TerminalSession) -> Project? {
       guard let workingDirectory = session.workingDirectory,
             let modelContext = modelContext else {
           return nil
       }

       // Fetch projects with matching path
       var descriptor = FetchDescriptor<Project>()
       descriptor.predicate = #Predicate { $0.path == workingDirectory }

       do {
           let projects = try modelContext.fetch(descriptor)
           if let project = projects.first {
               session.project = project
               logInfo("Associated session '\(session.name)' with project '\(project.name)'", category: .terminal)
               return project
           }
       } catch {
           logError("Failed to find project for path \(workingDirectory): \(error)", category: .terminal)
       }

       return nil
   }
   ```

3. Add method to resume a persisted session:
   ```swift
   /// Resume a persisted session by adding it to active sessions
   /// - Parameter session: The persisted TerminalSession from SwiftData
   /// - Returns: true if resumed, false if max sessions reached
   @discardableResult
   func resumePersistedSession(_ session: TerminalSession) -> Bool {
       guard canCreateSession else {
           logWarning("Cannot resume session: max limit reached", category: .terminal)
           return false
       }

       // Add to active sessions array
       sessions.append(session)

       // Update activity timestamp
       session.updateActivity()

       // Auto-activate if first session
       if activeSessionId == nil {
           activeSessionId = session.id
       }

       logInfo("Resumed persisted session: \(session.name) (\(session.id))", category: .terminal)
       return true
   }
   ```

4. Add method to clean up stale sessions from SwiftData:
   ```swift
   /// Remove sessions older than specified days from SwiftData
   /// - Parameter olderThanDays: Delete sessions with lastActivity older than this many days
   func cleanupStaleSessions(olderThanDays: Int = 7) {
       guard let modelContext = modelContext else { return }

       let cutoff = Date().addingTimeInterval(-Double(olderThanDays) * 24 * 3600)
       var descriptor = FetchDescriptor<TerminalSession>()
       descriptor.predicate = #Predicate { $0.lastActivity < cutoff }

       do {
           let staleSessions = try modelContext.fetch(descriptor)
           for session in staleSessions {
               modelContext.delete(session)
               logDebug("Deleted stale session: \(session.name)", category: .terminal)
           }
           if !staleSessions.isEmpty {
               logInfo("Cleaned up \(staleSessions.count) stale sessions", category: .terminal)
           }
       } catch {
           logError("Failed to cleanup stale sessions: \(error)", category: .terminal)
       }
   }
   ```
  </action>
  <verify>
Build succeeds: `xcodebuild -scheme Dispatch -destination 'platform=macOS' build 2>&1 | grep -E "(error:|BUILD SUCCEEDED)"`
  </verify>
  <done>
TerminalSessionManager has loadPersistedSessions(), associateWithProject(), resumePersistedSession(), and cleanupStaleSessions() methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update MultiSessionTerminalView to load and resume persisted sessions</name>
  <files>
    Dispatch/Views/Terminal/MultiSessionTerminalView.swift
  </files>
  <action>
Update MultiSessionTerminalView to load persisted sessions on launch and offer resume:

1. Add state for persisted sessions:
   ```swift
   @State private var persistedSessions: [TerminalSession] = []
   @State private var showPersistedSessionsPicker = false
   ```

2. Update onAppear logic to prioritize persisted sessions:
   ```swift
   .onAppear {
       if sessionManager.sessions.isEmpty && !hasCheckedForSessions {
           hasCheckedForSessions = true

           // First, check for persisted sessions from SwiftData
           persistedSessions = sessionManager.loadPersistedSessions()

           if !persistedSessions.isEmpty {
               // Has persisted sessions - show picker to resume or start fresh
               showPersistedSessionsPicker = true
           } else {
               // No persisted sessions - check Claude Code session files for discovery
               Task {
                   await checkForRecentSessions()
               }
           }
       }
   }
   ```

3. Add sheet for persisted sessions picker:
   ```swift
   .sheet(isPresented: $showPersistedSessionsPicker) {
       PersistedSessionPicker(
           sessions: persistedSessions,
           onResume: { session in
               // Resume the persisted session
               if sessionManager.resumePersistedSession(session) {
                   // Try to associate with project
                   sessionManager.associateWithProject(session)
               }
           },
           onStartFresh: {
               // User wants fresh session - create new one
               _ = sessionManager.createSession()
           },
           onDismiss: {
               // User dismissed without choice - create fresh session
               if sessionManager.sessions.isEmpty {
                   _ = sessionManager.createSession()
               }
           }
       )
   }
   ```

4. Create the PersistedSessionPicker view inline or as a separate private struct:
   ```swift
   private struct PersistedSessionPicker: View {
       let sessions: [TerminalSession]
       let onResume: (TerminalSession) -> Void
       let onStartFresh: () -> Void
       let onDismiss: () -> Void

       @Environment(\.dismiss) private var dismiss

       var body: some View {
           VStack(spacing: 0) {
               // Header
               HStack {
                   Text("Resume Previous Session")
                       .font(.headline)
                   Spacer()
                   Button("Cancel") {
                       onDismiss()
                       dismiss()
                   }
                   .buttonStyle(.plain)
                   .foregroundStyle(.secondary)
               }
               .padding()

               Divider()

               if sessions.isEmpty {
                   ContentUnavailableView(
                       "No Previous Sessions",
                       systemImage: "clock.arrow.circlepath",
                       description: Text("No sessions found to resume")
                   )
                   .frame(minHeight: 200)
               } else {
                   ScrollView {
                       LazyVStack(spacing: 8) {
                           ForEach(sessions) { session in
                               PersistedSessionRow(session: session) {
                                   onResume(session)
                                   dismiss()
                               }
                           }
                       }
                       .padding()
                   }
                   .frame(maxHeight: 300)
               }

               Divider()

               HStack {
                   Spacer()
                   Button("Start Fresh Session") {
                       onStartFresh()
                       dismiss()
                   }
                   .buttonStyle(.borderedProminent)
               }
               .padding()
           }
           .frame(width: 450)
       }
   }

   private struct PersistedSessionRow: View {
       let session: TerminalSession
       let onTap: () -> Void

       var body: some View {
           Button(action: onTap) {
               HStack(spacing: 12) {
                   VStack(alignment: .leading, spacing: 4) {
                       Text(session.name)
                           .font(.body)
                           .foregroundStyle(.primary)

                       HStack(spacing: 8) {
                           if session.isResumable {
                               Label("Resumable", systemImage: "arrow.clockwise")
                                   .font(.caption)
                                   .foregroundStyle(.green)
                           }

                           Text(session.relativeLastActivity)
                               .font(.caption)
                               .foregroundStyle(.tertiary)
                       }
                   }

                   Spacer()

                   Image(systemName: "arrow.right.circle")
                       .foregroundStyle(.secondary)
                       .imageScale(.large)
               }
               .padding(10)
               .background(Color(nsColor: .controlBackgroundColor))
               .clipShape(RoundedRectangle(cornerRadius: 8))
               .overlay(
                   RoundedRectangle(cornerRadius: 8)
                       .stroke(Color.secondary.opacity(0.2), lineWidth: 1)
               )
           }
           .buttonStyle(.plain)
       }
   }
   ```

5. Cleanup stale sessions on appear (after loading):
   Add to the onAppear block after loading:
   ```swift
   // Cleanup old sessions in background
   Task.detached {
       await MainActor.run {
           sessionManager.cleanupStaleSessions(olderThanDays: 7)
       }
   }
   ```
  </action>
  <verify>
Build succeeds: `xcodebuild -scheme Dispatch -destination 'platform=macOS' build 2>&1 | grep -E "(error:|BUILD SUCCEEDED)"`
  </verify>
  <done>
MultiSessionTerminalView loads persisted sessions on launch, shows picker to resume or start fresh, auto-associates with projects, cleans up stale sessions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add stale Claude session detection and graceful fallback</name>
  <files>
    Dispatch/Views/Terminal/EmbeddedTerminalView.swift
    Dispatch/Services/TerminalSessionManager.swift
  </files>
  <action>
Add detection for stale Claude Code sessions (session file deleted) and fallback to fresh session:

1. In TerminalSessionManager, add method to verify Claude session exists:
   ```swift
   /// Check if a Claude Code session ID is still valid (file exists)
   /// - Parameter sessionId: The Claude session ID to verify
   /// - Parameter workingDirectory: The project path for the session
   /// - Returns: true if session file exists, false if stale/deleted
   func isClaudeSessionValid(sessionId: String, workingDirectory: String?) async -> Bool {
       guard let workingDirectory = workingDirectory else {
           // Can't verify without path - assume valid
           return true
       }

       // Use discovery service to check if session exists
       let sessions = await ClaudeSessionDiscoveryService.shared.discoverSessions(for: workingDirectory)
       return sessions.contains { $0.sessionId == sessionId }
   }

   /// Handle failed session resume by creating fresh session
   /// Called when Claude Code reports session not found
   func handleStaleSession(_ sessionId: UUID) {
       guard let session = sessions.first(where: { $0.id == sessionId }) else { return }

       logWarning("Session '\(session.name)' was stale, clearing Claude session ID", category: .terminal)

       // Clear the stale Claude session ID so it won't try to resume again
       session.claudeSessionId = nil
       session.updateActivity()

       // Note: The terminal will need to be recreated to launch fresh
       // For now, just clear the session ID - user can close and reopen
   }
   ```

2. In EmbeddedTerminalView, add monitoring for stale session detection:
   After terminal launches in makeNSView(), add async check:
   ```swift
   // For resume mode, verify session is valid
   if case let .claudeCodeResume(claudeSessionId, workingDirectory, _) = launchMode {
       Task {
           // Wait for terminal to initialize
           try? await Task.sleep(nanoseconds: 3_000_000_000) // 3s

           // Check terminal content for error patterns
           if let terminal = context.coordinator.terminalView {
               let terminalInstance = terminal.getTerminal()
               let data = terminalInstance.getBufferAsData()
               if let content = String(data: data, encoding: .utf8) {
                   if content.contains("Session not found") ||
                      content.contains("No session") ||
                      content.contains("does not exist") {
                       await MainActor.run {
                           if let sessionId = sessionId {
                               TerminalSessionManager.shared.handleStaleSession(sessionId)
                           }
                       }
                   }
               }
           }
       }
   }
   ```

3. Add lastActivity update on session activity:
   In EmbeddedTerminalView Coordinator's dispatchPrompt method, add activity update:
   ```swift
   func dispatchPrompt(_ prompt: String) -> Bool {
       // ... existing code ...

       // Update session activity
       if let sessionId = sessionId {
           TerminalSessionManager.shared.updateSessionActivity(sessionId)
       }

       // ... rest of existing code ...
   }
   ```
  </action>
  <verify>
Build succeeds and app runs: `xcodebuild -scheme Dispatch -destination 'platform=macOS' build 2>&1 | grep -E "(error:|BUILD SUCCEEDED)"`
  </verify>
  <done>
Stale Claude sessions are detected via terminal output patterns. Session activity is updated on prompt dispatch. Stale sessions have claudeSessionId cleared for fresh start.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with no errors
2. Launch app with no prior sessions - creates fresh session automatically
3. Create session, quit app, relaunch - shows persisted session picker
4. Resume persisted session - session loads with same name
5. If session had claudeSessionId, terminal uses --resume flag
6. If claude -r fails (Session not found), claudeSessionId is cleared
7. Check SwiftData: `sqlite3 ~/Library/Application\ Support/Dispatch/default.store "SELECT name, claudeSessionId, lastActivity FROM ZTERMINALSESSION;"`
</verification>

<success_criteria>
- Persisted sessions load from SwiftData on app launch
- Resume picker shows for persisted sessions
- Fresh session created if no persisted sessions
- Sessions auto-associate with Projects by path
- Stale Claude sessions detected and handled gracefully
- lastActivity updated on prompt dispatch
- Stale sessions cleaned up after 7 days
</success_criteria>

<output>
After completion, create `.planning/phases/19-session-persistence/19-02-SUMMARY.md`
</output>

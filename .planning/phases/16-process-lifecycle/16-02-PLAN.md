---
phase: 16-process-lifecycle
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - Dispatch/Services/TerminalProcessRegistry.swift
  - Dispatch/Views/Terminal/EmbeddedTerminalView.swift
  - Dispatch/DispatchApp.swift
autonomous: true

must_haves:
  truths:
    - "Terminal PIDs are registered when process starts"
    - "Terminal PIDs are unregistered when process exits"
    - "Orphaned processes from previous session are terminated on app launch"
    - "Process termination kills both shell and child processes (Claude Code)"
    - "SIGTERM is sent first, SIGKILL only after timeout"
  artifacts:
    - path: "Dispatch/Services/TerminalProcessRegistry.swift"
      provides: "Process lifecycle utilities (isProcessRunning, terminateProcessGroupGracefully, cleanupOrphanedProcesses)"
      min_lines: 100
    - path: "Dispatch/Views/Terminal/EmbeddedTerminalView.swift"
      provides: "Registry integration in Coordinator"
      contains: "TerminalProcessRegistry.shared"
    - path: "Dispatch/DispatchApp.swift"
      provides: "Orphan cleanup call in setupApp"
      contains: "cleanupOrphanedProcesses"
  key_links:
    - from: "EmbeddedTerminalView.Coordinator"
      to: "TerminalProcessRegistry.shared"
      via: "register in makeNSView, unregister in processTerminated/deinit"
      pattern: "TerminalProcessRegistry\\.shared\\.(register|unregister)"
    - from: "setupApp()"
      to: "TerminalProcessRegistry.shared.cleanupOrphanedProcesses()"
      via: "function call on launch"
      pattern: "cleanupOrphanedProcesses"
    - from: "Coordinator.deinit"
      to: "killpg"
      via: "terminateProcessGroupGracefully"
      pattern: "killpg.*SIGTERM|terminateProcessGroupGracefully"
---

<objective>
Implement graceful process termination and orphan cleanup to complete the process lifecycle system.

Purpose: Ensure no orphaned processes persist across app crashes/restarts, and that closing a terminal kills both the shell and any child processes like Claude Code.

Output: Complete integration of TerminalProcessRegistry with EmbeddedTerminalView, process group termination, and orphan cleanup on launch.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-process-lifecycle/16-RESEARCH.md
@.planning/phases/16-process-lifecycle/16-01-SUMMARY.md

## Key Research Findings

From 16-RESEARCH.md:
- SwiftTerm uses POSIX_SPAWN_SETSID, so shellPid == PGID
- Use killpg(pgid, signal) to terminate entire process group
- kill(pid, 0) checks if process exists without sending signal
- errno == ESRCH means process not found, EPERM means exists but no permission
- Two-stage: SIGTERM -> 2-3s timeout -> SIGKILL
- Access shellPid immediately after startProcess() returns

## Current EmbeddedTerminalView Structure

Coordinator already has:
- terminalView: LocalProcessTerminalView? property
- deinit that calls terminalView?.terminate()
- processTerminated delegate method
- sendIfRunning helper

Need to add:
- Register PID after startProcess
- Unregister in processTerminated
- Use killpg in deinit instead of just terminate()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add process lifecycle utilities to TerminalProcessRegistry</name>
  <files>Dispatch/Services/TerminalProcessRegistry.swift</files>
  <action>
Add three new methods to TerminalProcessRegistry for process lifecycle management:

1. `isProcessRunning(_ pid: pid_t) -> Bool` - Uses kill(pid, 0) to check existence
2. `terminateProcessGroupGracefully(pgid: pid_t, timeout: TimeInterval)` - Two-stage SIGTERM/SIGKILL
3. `cleanupOrphanedProcesses()` - For app launch cleanup

Add to the class after existing methods:

```swift
// MARK: - Process Lifecycle

/// Check if a process is still running using kill(pid, 0)
func isProcessRunning(_ pid: pid_t) -> Bool {
    let result = kill(pid, 0)

    if result == 0 {
        return true  // Process exists and we have permission
    }

    // Check errno to distinguish cases
    switch errno {
    case ESRCH:
        return false  // No such process
    case EPERM:
        return true   // Process exists but no permission (still running)
    default:
        logDebug("Unexpected errno \(errno) checking PID \(pid)", category: .terminal)
        return false
    }
}

/// Terminate a process group gracefully (SIGTERM -> wait -> SIGKILL)
/// - Parameters:
///   - pgid: Process group ID (same as shell PID due to POSIX_SPAWN_SETSID)
///   - timeout: Seconds to wait for graceful shutdown before SIGKILL
func terminateProcessGroupGracefully(pgid: pid_t, timeout: TimeInterval = 3.0) {
    // Stage 1: Send SIGTERM to process group
    let termResult = killpg(pgid, SIGTERM)

    if termResult == -1 && errno == ESRCH {
        logDebug("Process group \(pgid) already terminated", category: .terminal)
        return
    }

    logDebug("Sent SIGTERM to process group \(pgid)", category: .terminal)

    // Stage 2: Wait for graceful shutdown
    let deadline = Date().addingTimeInterval(timeout)
    var gracefullyTerminated = false

    while Date() < deadline {
        if !isProcessRunning(pgid) {
            gracefullyTerminated = true
            logDebug("Process group \(pgid) terminated gracefully", category: .terminal)
            break
        }
        Thread.sleep(forTimeInterval: 0.1)
    }

    // Stage 3: Force termination if still running
    if !gracefullyTerminated {
        logDebug("Process group \(pgid) timeout, sending SIGKILL", category: .terminal)
        killpg(pgid, SIGKILL)
        Thread.sleep(forTimeInterval: 0.1)
    }
}

/// Clean up orphaned processes from crashed/force-quit sessions
/// Call this on app launch
func cleanupOrphanedProcesses() {
    let persistedPIDs = getAllPIDs()

    guard !persistedPIDs.isEmpty else {
        logDebug("No persisted PIDs to clean up", category: .terminal)
        return
    }

    logInfo("Checking \(persistedPIDs.count) persisted PIDs for orphans", category: .terminal)

    for pid in persistedPIDs {
        if isProcessRunning(pid) {
            logInfo("Found orphaned process \(pid), terminating process group", category: .terminal)
            terminateProcessGroupGracefully(pgid: pid, timeout: 2.0)
        } else {
            logDebug("Stale PID \(pid) no longer running", category: .terminal)
        }

        // Remove from registry either way
        unregister(pid: pid)
    }

    logInfo("Orphan cleanup complete", category: .terminal)
}
```

Note: `kill` and `killpg` are from Darwin (already available via Foundation import).
  </action>
  <verify>
```bash
# Has isProcessRunning method
grep "func isProcessRunning" Dispatch/Services/TerminalProcessRegistry.swift

# Has terminateProcessGroupGracefully method
grep "func terminateProcessGroupGracefully" Dispatch/Services/TerminalProcessRegistry.swift

# Has cleanupOrphanedProcesses method
grep "func cleanupOrphanedProcesses" Dispatch/Services/TerminalProcessRegistry.swift

# Uses killpg for process group termination
grep "killpg.*SIGTERM" Dispatch/Services/TerminalProcessRegistry.swift
grep "killpg.*SIGKILL" Dispatch/Services/TerminalProcessRegistry.swift
```
  </verify>
  <done>TerminalProcessRegistry has isProcessRunning, terminateProcessGroupGracefully (with two-stage SIGTERM/SIGKILL), and cleanupOrphanedProcesses methods</done>
</task>

<task type="auto">
  <name>Task 2: Integrate registry with EmbeddedTerminalView</name>
  <files>Dispatch/Views/Terminal/EmbeddedTerminalView.swift</files>
  <action>
Modify EmbeddedTerminalView to register/unregister PIDs and use process group termination:

1. In `makeNSView`, register PID after startProcess:

```swift
func makeNSView(context: Context) -> LocalProcessTerminalView {
    logDebug("Creating embedded terminal view", category: .terminal)

    let terminal = LocalProcessTerminalView(frame: .zero)
    terminal.processDelegate = context.coordinator

    let shell = ProcessInfo.processInfo.environment["SHELL"] ?? "/bin/bash"
    logInfo("Starting shell: \(shell)", category: .terminal)

    terminal.startProcess(executable: shell)

    // Store reference in coordinator for cleanup
    context.coordinator.terminalView = terminal

    // Register PID for crash recovery
    let pid = terminal.shellPid
    if pid > 0 {
        TerminalProcessRegistry.shared.register(pid: pid)
        logInfo("Terminal process started with PID \(pid)", category: .terminal)
    }

    return terminal
}
```

2. In Coordinator.processTerminated, unregister PID:

```swift
func processTerminated(source _: TerminalView, exitCode: Int32?) {
    logDebug("Terminal process exited with code: \(exitCode ?? -1)", category: .terminal)

    // Unregister from tracking when process exits naturally
    if let terminal = terminalView {
        TerminalProcessRegistry.shared.unregister(pid: terminal.shellPid)
    }

    // Clear reference since process is gone
    terminalView = nil
    DispatchQueue.main.async {
        self.onProcessExit?(exitCode)
    }
}
```

3. In Coordinator.deinit, use process group termination:

```swift
deinit {
    logDebug("Coordinator deinit - terminating process group", category: .terminal)

    guard let terminal = terminalView else { return }
    let pid = terminal.shellPid

    // Terminate entire process group (shell + children like Claude Code)
    TerminalProcessRegistry.shared.terminateProcessGroupGracefully(pgid: pid, timeout: 2.0)

    // Unregister after termination
    TerminalProcessRegistry.shared.unregister(pid: pid)

    terminalView = nil
}
```
  </action>
  <verify>
```bash
# Registers PID after startProcess
grep "TerminalProcessRegistry.shared.register" Dispatch/Views/Terminal/EmbeddedTerminalView.swift

# Unregisters in processTerminated
grep -A5 "func processTerminated" Dispatch/Views/Terminal/EmbeddedTerminalView.swift | grep "unregister"

# Uses process group termination in deinit
grep -A10 "deinit" Dispatch/Views/Terminal/EmbeddedTerminalView.swift | grep "terminateProcessGroupGracefully"
```
  </verify>
  <done>EmbeddedTerminalView registers PIDs on spawn, unregisters on exit, and uses killpg via terminateProcessGroupGracefully in deinit</done>
</task>

<task type="auto">
  <name>Task 3: Add orphan cleanup to app startup</name>
  <files>Dispatch/DispatchApp.swift</files>
  <action>
Add orphan cleanup call to setupApp() in DispatchApp.swift.

Add near the beginning of setupApp(), before other async Tasks:

```swift
private func setupApp() {
    logInfo("Dispatch app starting", category: .app)

    // Clean up orphaned terminal processes from previous session
    TerminalProcessRegistry.shared.cleanupOrphanedProcesses()

    // Configure settings manager
    SettingsManager.shared.configure(with: sharedModelContainer.mainContext)

    // ... rest of existing setup
}
```

The cleanup is synchronous and fast (just sends signals), so it runs before async hooks/services start.
  </action>
  <verify>
```bash
# Has orphan cleanup call in setupApp
grep "cleanupOrphanedProcesses" Dispatch/DispatchApp.swift

# Cleanup happens early in setupApp
grep -A3 "Dispatch app starting" Dispatch/DispatchApp.swift | grep "cleanupOrphanedProcesses"
```
  </verify>
  <done>DispatchApp.setupApp() calls TerminalProcessRegistry.shared.cleanupOrphanedProcesses() on launch</done>
</task>

</tasks>

<verification>
1. Build succeeds: `xcodebuild -scheme Dispatch build` shows BUILD SUCCEEDED
2. Registry has lifecycle methods: `grep -c "func.*Process" Dispatch/Services/TerminalProcessRegistry.swift` returns 3+
3. EmbeddedTerminalView integrates registry: `grep -c "TerminalProcessRegistry" Dispatch/Views/Terminal/EmbeddedTerminalView.swift` returns 3+
4. App calls cleanup on launch: `grep -c "cleanupOrphanedProcesses" Dispatch/DispatchApp.swift` returns 1
</verification>

<success_criteria>
- TerminalProcessRegistry has isProcessRunning, terminateProcessGroupGracefully, cleanupOrphanedProcesses
- killpg used for process group termination (SIGTERM then SIGKILL)
- EmbeddedTerminalView registers PID after startProcess
- EmbeddedTerminalView unregisters PID in processTerminated and deinit
- DispatchApp.setupApp() calls cleanupOrphanedProcesses
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/16-process-lifecycle/16-02-SUMMARY.md`
</output>

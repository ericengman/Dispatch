---
phase: 16-process-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dispatch/Services/TerminalProcessRegistry.swift
autonomous: true

must_haves:
  truths:
    - "PIDs are tracked in memory with thread-safe access"
    - "PIDs persist to UserDefaults automatically on register/unregister"
    - "Persisted PIDs are loaded on initialization"
  artifacts:
    - path: "Dispatch/Services/TerminalProcessRegistry.swift"
      provides: "Centralized PID tracking with UserDefaults persistence"
      exports: ["TerminalProcessRegistry"]
      min_lines: 60
  key_links:
    - from: "TerminalProcessRegistry"
      to: "UserDefaults.standard"
      via: "persist() method"
      pattern: "defaults\\.set.*forKey"
---

<objective>
Create TerminalProcessRegistry service for tracking spawned terminal process PIDs across sessions.

Purpose: Enable crash recovery by persisting PIDs to UserDefaults so orphaned processes can be detected and cleaned up on app relaunch.

Output: Thread-safe singleton service with register/unregister/getAllPIDs API that automatically persists to UserDefaults.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-process-lifecycle/16-RESEARCH.md

## Key Research Findings

From 16-RESEARCH.md:
- Use UserDefaults for persistence (automatic async sync, no synchronize() needed)
- NSLock for thread safety (multiple terminal sessions may register concurrently)
- Store as [Int] array (UserDefaults handles natively)
- Key: "Dispatch.ActiveProcessPIDs"
- pid_t is Int32, convert to Int for UserDefaults storage
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TerminalProcessRegistry service</name>
  <files>Dispatch/Services/TerminalProcessRegistry.swift</files>
  <action>
Create new service file implementing the registry pattern from research:

```swift
import Foundation

/// Tracks active terminal process PIDs for crash recovery
/// PIDs persist to UserDefaults to enable orphan cleanup on relaunch
class TerminalProcessRegistry {
    static let shared = TerminalProcessRegistry()

    private let defaults = UserDefaults.standard
    private let defaultsKey = "Dispatch.ActiveProcessPIDs"
    private let lock = NSLock()
    private var activePIDs: Set<pid_t> = []

    private init() {
        loadPersistedPIDs()
    }

    private func loadPersistedPIDs() {
        lock.lock()
        defer { lock.unlock() }

        let stored = defaults.array(forKey: defaultsKey) as? [Int] ?? []
        activePIDs = Set(stored.map { pid_t($0) })

        logDebug("Loaded \(activePIDs.count) persisted PIDs", category: .terminal)
    }

    /// Register a spawned process PID for tracking
    func register(pid: pid_t) {
        guard pid > 0 else { return }

        lock.lock()
        defer { lock.unlock() }

        activePIDs.insert(pid)
        persist()

        logInfo("Registered process PID: \(pid)", category: .terminal)
    }

    /// Unregister a PID when process exits (natural or forced)
    func unregister(pid: pid_t) {
        lock.lock()
        defer { lock.unlock() }

        let wasPresent = activePIDs.remove(pid) != nil
        if wasPresent {
            persist()
            logInfo("Unregistered process PID: \(pid)", category: .terminal)
        }
    }

    private func persist() {
        // Convert pid_t to Int for UserDefaults storage
        let pidArray = Array(activePIDs).map { Int($0) }
        defaults.set(pidArray, forKey: defaultsKey)
        // DO NOT call synchronize() - deprecated, automatic sync is sufficient
    }

    /// Get all tracked PIDs (for orphan cleanup on launch)
    func getAllPIDs() -> Set<pid_t> {
        lock.lock()
        defer { lock.unlock() }
        return activePIDs
    }

    /// Check if a specific PID is being tracked
    func contains(pid: pid_t) -> Bool {
        lock.lock()
        defer { lock.unlock() }
        return activePIDs.contains(pid)
    }
}
```

Key implementation notes:
- Singleton pattern (static let shared)
- NSLock protects activePIDs set
- Load persisted PIDs in init
- persist() called after every mutation
- NO synchronize() call (deprecated)
- Use LoggingService for debug/info logging
  </action>
  <verify>
```bash
# File exists with correct structure
grep -c "class TerminalProcessRegistry" Dispatch/Services/TerminalProcessRegistry.swift

# Has singleton pattern
grep "static let shared" Dispatch/Services/TerminalProcessRegistry.swift

# Has UserDefaults persistence
grep "defaults.set.*forKey" Dispatch/Services/TerminalProcessRegistry.swift

# Has NSLock for thread safety
grep "private let lock = NSLock()" Dispatch/Services/TerminalProcessRegistry.swift

# Does NOT use deprecated synchronize()
! grep "synchronize()" Dispatch/Services/TerminalProcessRegistry.swift
```
  </verify>
  <done>TerminalProcessRegistry.swift exists with singleton, register/unregister/getAllPIDs methods, UserDefaults persistence, and NSLock thread safety</done>
</task>

<task type="auto">
  <name>Task 2: Verify build succeeds</name>
  <files>Dispatch/Services/TerminalProcessRegistry.swift</files>
  <action>
Build the project to verify the new service compiles correctly:

```bash
xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build
```

If build fails:
- Check for typos in LoggingService usage (logDebug, logInfo)
- Verify Foundation import
- Check pid_t type usage (Darwin.pid_t or just pid_t)
  </action>
  <verify>Build output shows "** BUILD SUCCEEDED **"</verify>
  <done>TerminalProcessRegistry compiles without errors, ready for integration in Plan 02</done>
</task>

</tasks>

<verification>
1. File exists: `ls Dispatch/Services/TerminalProcessRegistry.swift`
2. Build succeeds: `xcodebuild -scheme Dispatch build` shows BUILD SUCCEEDED
3. No synchronize() usage: `grep -c "synchronize" Dispatch/Services/TerminalProcessRegistry.swift` returns 0
</verification>

<success_criteria>
- TerminalProcessRegistry.swift created in Services directory
- Class has static shared singleton
- register(pid:) and unregister(pid:) methods exist
- getAllPIDs() returns Set<pid_t>
- UserDefaults persistence on every mutation
- NSLock for thread safety
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/16-process-lifecycle/16-01-SUMMARY.md`
</output>

---
phase: 20-service-integration
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - Dispatch/ViewModels/QueueViewModel.swift
  - Dispatch/ViewModels/ChainViewModel.swift
autonomous: false

must_haves:
  truths:
    - "Queue Run Next dispatches prompt to embedded terminal"
    - "Queue Run All executes all items sequentially through embedded terminal"
    - "Chain execution dispatches sequence with configured delays to embedded terminal"
    - "Completion detection works for queue and chain execution"
  artifacts:
    - path: "Dispatch/ViewModels/QueueViewModel.swift"
      provides: "Queue execution via ExecutionManager"
      contains: "ExecutionManager.shared.execute"
    - path: "Dispatch/ViewModels/ChainViewModel.swift"
      provides: "Chain execution via ExecutionManager"
      contains: "ExecutionManager.shared.execute"
  key_links:
    - from: "Dispatch/ViewModels/QueueViewModel.swift"
      to: "ExecutionManager"
      via: "execute() call in executeItem"
      pattern: "ExecutionManager\\.shared\\.execute"
    - from: "Dispatch/ViewModels/ChainViewModel.swift"
      to: "ExecutionManager"
      via: "execute() call in executeItem"
      pattern: "ExecutionManager\\.shared\\.execute"
---

<objective>
Verify and test queue/chain integration with embedded terminals

Purpose: INTG-02, INTG-03 require queue and chain execution to dispatch to embedded terminals. Research confirms this already works via ExecutionManager. This plan verifies the integration and adds a human verification checkpoint.

Output:
- Verified queue execution dispatches to embedded terminal
- Verified chain execution with delays works
- Human-verified end-to-end flow
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-service-integration/20-RESEARCH.md
@.planning/phases/20-service-integration/20-01-SUMMARY.md

@Dispatch/ViewModels/QueueViewModel.swift
@Dispatch/ViewModels/ChainViewModel.swift
@Dispatch/Services/ExecutionStateMachine.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify queue uses ExecutionManager path</name>
  <files>Dispatch/ViewModels/QueueViewModel.swift</files>
  <action>
Review QueueViewModel.executeItem() to confirm it uses ExecutionManager.execute().

Expected flow (from research):
1. executeItem() gets content from item.effectiveContent
2. Resolves placeholders via PlaceholderResolver.shared.autoResolve()
3. Calls ExecutionManager.shared.execute() with resolved content
4. ExecutionStateMachine handles state transitions
5. Completion handler (setupExecutionObserver) marks item complete/failed

Verify these are all present. If any step is missing or uses direct terminal access, add logging to confirm the path is correct.

Add a log statement at the start of executeItem to trace execution:
```swift
logInfo("Queue executing item: '\(item.displayTitle)' via ExecutionManager", category: .queue)
```

This makes it easy to verify in logs that queue items flow through ExecutionManager.
  </action>
  <verify>QueueViewModel.executeItem contains ExecutionManager.shared.execute call; new log statement present</verify>
  <done>Queue execution path verified to use ExecutionManager, log statement added for tracing</done>
</task>

<task type="auto">
  <name>Task 2: Verify chain uses ExecutionManager path</name>
  <files>Dispatch/ViewModels/ChainViewModel.swift</files>
  <action>
Review ChainViewModel.executeItem() to confirm it uses ExecutionManager.execute().

Expected flow (from research):
1. executeItem() gets content from item.effectiveContent
2. Resolves placeholders via PlaceholderResolver.shared.autoResolve()
3. Calls ExecutionManager.shared.execute() with resolved content
4. Waits for ExecutionStateMachine.shared.state to leave .executing
5. Applies delay if configured before next step

Verify these are all present. Add logging for chain step execution:
```swift
logInfo("Chain step \(index + 1)/\(totalSteps) executing via ExecutionManager", category: .chain)
```

After waiting for completion:
```swift
logInfo("Chain step \(index + 1) completed, state: \(ExecutionStateMachine.shared.state)", category: .chain)
```

If delay is applied:
```swift
logInfo("Chain applying \(item.delaySeconds)s delay before next step", category: .chain)
```
  </action>
  <verify>ChainViewModel.executeItem contains ExecutionManager.shared.execute call; new log statements present</verify>
  <done>Chain execution path verified to use ExecutionManager, log statements added for tracing</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Queue and chain execution integration with embedded terminals:
1. Created EmbeddedTerminalService (Plan 01)
2. ExecutionManager routes through EmbeddedTerminalService
3. Session activity updated on dispatch
4. Session validation in hook completion
5. Queue and chain both use ExecutionManager path
  </what-built>
  <how-to-verify>
Build and run the app, then test:

**Queue Test:**
1. Open Dispatch, ensure embedded terminal is visible with Claude Code running
2. Create or select a prompt in the library
3. Click "Add to Queue" (Cmd+Shift+Q)
4. Click "Run Next" in the queue panel
5. Verify:
   - Prompt appears in embedded terminal
   - Claude Code processes it
   - Queue item marked complete when done
   - Check logs for "Queue executing item: ... via ExecutionManager"

**Queue Run All Test:**
1. Add 2-3 prompts to queue
2. Click "Run All"
3. Verify:
   - Items execute sequentially
   - Each item waits for completion before next
   - All items eventually marked complete

**Chain Test:**
1. Create a chain with 2+ steps
2. Set a delay (e.g., 5 seconds) on first step
3. Click Play on the chain
4. Verify:
   - First step executes in embedded terminal
   - Delay applies after completion
   - Second step executes
   - Check logs for "Chain step X/Y executing via ExecutionManager"

**Session Activity Test:**
1. After running queue/chain items, check session in tab bar
2. Session should show recent activity (tooltip or lastActivity if visible)

**Fallback Test (Optional):**
1. Close embedded terminal panel (Cmd+Shift+T)
2. Add prompt to queue, run it
3. Verify it falls back to Terminal.app (opens Terminal, sends prompt)
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds: `xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build`
2. Queue uses ExecutionManager (grep QueueViewModel.swift for ExecutionManager.shared.execute)
3. Chain uses ExecutionManager (grep ChainViewModel.swift for ExecutionManager.shared.execute)
4. Human verified: Queue and chain work with embedded terminal
</verification>

<success_criteria>
- Queue "Run Next" dispatches prompt to embedded terminal, item completes
- Queue "Run All" executes multiple items sequentially
- Chain execution dispatches steps with delays
- Completion detection works (items marked complete/failed appropriately)
- Human verification confirms end-to-end flow works
- Fallback to Terminal.app works when embedded terminal unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/20-service-integration/20-02-SUMMARY.md`
</output>

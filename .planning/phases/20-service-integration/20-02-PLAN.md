---
phase: 20-service-integration
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - Dispatch/ViewModels/QueueViewModel.swift
  - Dispatch/ViewModels/ChainViewModel.swift
autonomous: true

must_haves:
  truths:
    - "Queue Run Next dispatches prompt to embedded terminal"
    - "Queue Run All executes all items sequentially through embedded terminal"
    - "Chain execution dispatches sequence with configured delays to embedded terminal"
    - "Completion detection works for queue and chain execution"
  artifacts:
    - path: "Dispatch/ViewModels/QueueViewModel.swift"
      provides: "Queue execution via ExecutionManager"
      contains: "ExecutionManager.shared.execute"
    - path: "Dispatch/ViewModels/ChainViewModel.swift"
      provides: "Chain execution via ExecutionManager"
      contains: "ExecutionManager.shared.execute"
  key_links:
    - from: "Dispatch/ViewModels/QueueViewModel.swift"
      to: "ExecutionManager"
      via: "execute() call in executeItem"
      pattern: "ExecutionManager\\.shared\\.execute"
    - from: "Dispatch/ViewModels/ChainViewModel.swift"
      to: "ExecutionManager"
      via: "execute() call in executeItem"
      pattern: "ExecutionManager\\.shared\\.execute"
---

<objective>
Verify and add logging for queue/chain integration with embedded terminals

Purpose: INTG-02, INTG-03 require queue and chain execution to dispatch to embedded terminals. Research confirms this already works via ExecutionManager. This plan adds logging for traceability and verifies the integration.

Output:
- Added tracing logs to queue and chain execution paths
- Verified queue execution dispatches to embedded terminal
- Verified chain execution with delays works
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-service-integration/20-RESEARCH.md
@.planning/phases/20-service-integration/20-01-SUMMARY.md

@Dispatch/ViewModels/QueueViewModel.swift
@Dispatch/ViewModels/ChainViewModel.swift
@Dispatch/Services/ExecutionStateMachine.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tracing logs to queue execution</name>
  <files>Dispatch/ViewModels/QueueViewModel.swift</files>
  <action>
Review QueueViewModel.executeItem() to confirm it uses ExecutionManager.execute().

Expected flow (from research):
1. executeItem() gets content from item.effectiveContent
2. Resolves placeholders via PlaceholderResolver.shared.autoResolve()
3. Calls ExecutionManager.shared.execute() with resolved content
4. ExecutionStateMachine handles state transitions
5. Completion handler (setupExecutionObserver) marks item complete/failed

Verify these are all present. If any step is missing or uses direct terminal access, add logging to confirm the path is correct.

Add a log statement at the start of executeItem to trace execution:
```swift
logInfo("Queue executing item: '\(item.displayTitle)' via ExecutionManager", category: .queue)
```

This makes it easy to verify in logs that queue items flow through ExecutionManager.
  </action>
  <verify>QueueViewModel.executeItem contains ExecutionManager.shared.execute call; new log statement present</verify>
  <done>Queue execution path verified to use ExecutionManager, log statement added for tracing</done>
</task>

<task type="auto">
  <name>Task 2: Add tracing logs to chain execution</name>
  <files>Dispatch/ViewModels/ChainViewModel.swift</files>
  <action>
Review ChainViewModel.executeItem() to confirm it uses ExecutionManager.execute().

Expected flow (from research):
1. executeItem() gets content from item.effectiveContent
2. Resolves placeholders via PlaceholderResolver.shared.autoResolve()
3. Calls ExecutionManager.shared.execute() with resolved content
4. Waits for ExecutionStateMachine.shared.state to leave .executing
5. Applies delay if configured before next step

Verify these are all present. Add logging for chain step execution:
```swift
logInfo("Chain step \(index + 1)/\(totalSteps) executing via ExecutionManager", category: .chain)
```

After waiting for completion:
```swift
logInfo("Chain step \(index + 1) completed, state: \(ExecutionStateMachine.shared.state)", category: .chain)
```

If delay is applied:
```swift
logInfo("Chain applying \(item.delaySeconds)s delay before next step", category: .chain)
```
  </action>
  <verify>ChainViewModel.executeItem contains ExecutionManager.shared.execute call; new log statements present</verify>
  <done>Chain execution path verified to use ExecutionManager, log statements added for tracing</done>
</task>

<task type="auto">
  <name>Task 3: Build and manual end-to-end verification</name>
  <files></files>
  <action>
Build the app and perform manual end-to-end verification:

```bash
xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build
```

After build succeeds, run the app and test:

**Queue Test:**
1. Open Dispatch, ensure embedded terminal is visible with Claude Code running
2. Create or select a prompt in the library
3. Click "Add to Queue" (Cmd+Shift+Q)
4. Click "Run Next" in the queue panel
5. Verify in logs: "Queue executing item: ... via ExecutionManager"
6. Verify prompt appears in embedded terminal
7. Verify queue item marked complete when done

**Chain Test:**
1. Create a chain with 2+ steps (can use simple prompts like "echo test")
2. Click Play on the chain
3. Verify in logs: "Chain step X/Y executing via ExecutionManager"
4. Verify steps execute in sequence

**Fallback Test:**
1. Close embedded terminal panel (Cmd+Shift+T)
2. Add prompt to queue, run it
3. Verify it falls back to Terminal.app

Document any issues found for potential gap closure.
  </action>
  <verify>
Build succeeds.
Queue Run Next works with embedded terminal (verify in logs).
Chain execution works (verify in logs).
Fallback to Terminal.app works when embedded terminal unavailable.
  </verify>
  <done>End-to-end verification complete, queue and chain integration working with embedded terminals</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds: `xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build`
2. Queue uses ExecutionManager (grep QueueViewModel.swift for ExecutionManager.shared.execute)
3. Chain uses ExecutionManager (grep ChainViewModel.swift for ExecutionManager.shared.execute)
4. Tracing logs present in both ViewModels
5. Manual verification confirms queue and chain work with embedded terminal
</verification>

<success_criteria>
- Queue "Run Next" dispatches prompt to embedded terminal, item completes
- Queue "Run All" executes multiple items sequentially
- Chain execution dispatches steps with delays
- Completion detection works (items marked complete/failed appropriately)
- Tracing logs visible in console during execution
- Fallback to Terminal.app works when embedded terminal unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/20-service-integration/20-02-SUMMARY.md`
</output>

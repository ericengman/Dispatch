---
phase: 20-service-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dispatch/Services/EmbeddedTerminalService.swift
  - Dispatch/Services/ExecutionStateMachine.swift
  - Dispatch/Services/EmbeddedTerminalBridge.swift
autonomous: true

must_haves:
  truths:
    - "EmbeddedTerminalService provides same dispatch API as TerminalService fallback"
    - "Dispatching prompt updates session activity timestamp"
    - "Hook completion validates session ID matches executing session"
  artifacts:
    - path: "Dispatch/Services/EmbeddedTerminalService.swift"
      provides: "Dispatch interface for embedded terminals"
      min_lines: 40
      exports: ["EmbeddedTerminalService"]
  key_links:
    - from: "Dispatch/Services/ExecutionStateMachine.swift"
      to: "EmbeddedTerminalService"
      via: "Uses EmbeddedTerminalService.shared for dispatch"
      pattern: "EmbeddedTerminalService\\.shared"
    - from: "Dispatch/Services/EmbeddedTerminalService.swift"
      to: "EmbeddedTerminalBridge"
      via: "Delegates to bridge for actual dispatch"
      pattern: "EmbeddedTerminalBridge\\.shared"
---

<objective>
Create EmbeddedTerminalService as explicit dispatch interface and add session validation

Purpose: INTG-01 requires explicit service class implementing dispatch interface (parallel to TerminalService). Also hardens multi-session dispatch by validating completion hooks match executing session.

Output:
- EmbeddedTerminalService.swift - Thin service wrapper around EmbeddedTerminalBridge
- Updated ExecutionStateMachine - Session validation in completion handler
- Updated EmbeddedTerminalBridge - Activity timestamp update on dispatch
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-service-integration/20-RESEARCH.md

@Dispatch/Services/EmbeddedTerminalBridge.swift
@Dispatch/Services/ExecutionStateMachine.swift
@Dispatch/Services/TerminalService.swift
@Dispatch/Services/TerminalSessionManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmbeddedTerminalService</name>
  <files>Dispatch/Services/EmbeddedTerminalService.swift</files>
  <action>
Create EmbeddedTerminalService as explicit service class parallel to TerminalService:

```swift
/// Service for dispatching prompts to embedded terminals (PTY-based)
/// Wraps EmbeddedTerminalBridge to provide service-layer interface
@MainActor
final class EmbeddedTerminalService {
    static let shared = EmbeddedTerminalService()

    private let bridge = EmbeddedTerminalBridge.shared
    private let sessionManager = TerminalSessionManager.shared

    private init() {}

    // MARK: - Availability

    /// Check if any embedded terminal is available for dispatch
    var isAvailable: Bool { bridge.isAvailable }

    /// Check if specific session is available
    func isAvailable(sessionId: UUID) -> Bool {
        bridge.isAvailable(sessionId: sessionId)
    }

    // MARK: - Session Info

    /// Currently active session ID (for targeting/tracking)
    var activeSessionId: UUID? { sessionManager.activeSessionId }

    /// Get terminal for session (for completion monitoring)
    func getTerminal(for sessionId: UUID) -> LocalProcessTerminalView? {
        bridge.getTerminal(for: sessionId)
    }

    // MARK: - Dispatch

    /// Dispatch prompt to active session
    /// Updates session activity timestamp on successful dispatch
    @discardableResult
    func dispatchPrompt(_ content: String) -> Bool {
        let result = bridge.dispatchPrompt(content)
        if result, let sessionId = sessionManager.activeSessionId {
            sessionManager.updateSessionActivity(sessionId)
        }
        return result
    }

    /// Dispatch prompt to specific session
    /// Updates session activity timestamp on successful dispatch
    @discardableResult
    func dispatchPrompt(_ content: String, to sessionId: UUID) -> Bool {
        let result = bridge.dispatchPrompt(content, to: sessionId)
        if result {
            sessionManager.updateSessionActivity(sessionId)
        }
        return result
    }
}
```

Key points:
- Singleton pattern matches TerminalService
- @MainActor for SwiftUI compatibility
- Delegates to EmbeddedTerminalBridge (avoids duplication)
- Updates session activity on dispatch (PERS-05 compliance)
- Both legacy (active session) and session-aware APIs
  </action>
  <verify>File exists at Dispatch/Services/EmbeddedTerminalService.swift with EmbeddedTerminalService class, dispatchPrompt methods, and import SwiftTerm</verify>
  <done>EmbeddedTerminalService.swift created with parallel API to TerminalService, activity tracking on dispatch</done>
</task>

<task type="auto">
  <name>Task 2: Wire ExecutionManager to EmbeddedTerminalService</name>
  <files>Dispatch/Services/ExecutionStateMachine.swift</files>
  <action>
Update ExecutionManager.execute() to use EmbeddedTerminalService instead of direct EmbeddedTerminalBridge access:

1. Add import for EmbeddedTerminalService (if needed - same module)

2. In execute() method, replace:
```swift
let bridge = EmbeddedTerminalBridge.shared
if bridge.isAvailable {
    let dispatched = bridge.dispatchPrompt(content)
```

With:
```swift
let embeddedService = EmbeddedTerminalService.shared
if embeddedService.isAvailable {
    let dispatched = embeddedService.dispatchPrompt(content)
```

3. Update terminal monitoring to get terminal from service:
```swift
if let sessionId = embeddedService.activeSessionId,
   let terminal = embeddedService.getTerminal(for: sessionId) {
    stateMachine.startEmbeddedTerminalMonitoring(terminal: terminal)
}
```

4. Track executing session ID for completion validation:
- Add property to ExecutionStateMachine: `private var executingSessionId: UUID?`
- Set in beginSending() when embedded terminal path taken
- Clear in transitionToIdle()

5. Add session validation in handleHookCompletion():
```swift
func handleHookCompletion(sessionId: String?) {
    guard state == .executing else {
        logDebug("Ignoring hook completion in state: \(state)", category: .execution)
        return
    }

    // Validate session if we have expected session ID
    if let executing = executingSessionId,
       let hookSession = sessionId,
       let hookUUID = UUID(uuidString: hookSession),
       hookUUID != executing {
        logWarning("Ignoring hook from different session: expected \(executing), got \(hookSession)", category: .execution)
        return
    }

    logInfo("Completion detected via hook (session: \(sessionId ?? "unknown"))", category: .execution)
    markCompleted(result: .success)
}
```

This prevents cross-session completion confusion when multiple sessions are active.
  </action>
  <verify>Build succeeds with xcodebuild; search for EmbeddedTerminalService.shared in ExecutionStateMachine.swift; search for executingSessionId property</verify>
  <done>ExecutionManager uses EmbeddedTerminalService, tracks executing session, validates hook completions match session</done>
</task>

<task type="auto">
  <name>Task 3: Add session ID to execution context</name>
  <files>Dispatch/Services/ExecutionStateMachine.swift</files>
  <action>
Extend ExecutionContext to include session targeting:

1. Add optional sessionId to ExecutionContext struct:
```swift
struct ExecutionContext: Sendable {
    let promptContent: String
    let promptTitle: String
    let targetWindowId: String?  // Terminal.app window ID (legacy)
    let targetWindowName: String?
    let targetSessionId: UUID?   // NEW: Embedded terminal session ID
    let isFromChain: Bool
    let chainName: String?
    let chainStepIndex: Int?
    let chainTotalSteps: Int?
    let startTime: Date

    init(
        promptContent: String,
        promptTitle: String,
        targetWindowId: String? = nil,
        targetWindowName: String? = nil,
        targetSessionId: UUID? = nil,  // NEW
        isFromChain: Bool = false,
        chainName: String? = nil,
        chainStepIndex: Int? = nil,
        chainTotalSteps: Int? = nil
    ) {
        // ... existing init body plus:
        self.targetSessionId = targetSessionId
    }
}
```

2. Update ExecutionManager.execute() signature to accept optional targetSessionId:
```swift
func execute(
    content: String,
    title: String = "Prompt",
    targetWindowId: String? = nil,
    targetWindowName: String? = nil,
    targetSessionId: UUID? = nil,  // NEW
    isFromChain: Bool = false,
    // ... rest of parameters
) async throws
```

3. Use targetSessionId if provided, otherwise use active session:
```swift
let embeddedService = EmbeddedTerminalService.shared
let sessionToUse = targetSessionId ?? embeddedService.activeSessionId

if let sessionId = sessionToUse, embeddedService.isAvailable(sessionId: sessionId) {
    // Dispatch to specific session
    let dispatched = embeddedService.dispatchPrompt(content, to: sessionId)
    executingSessionId = sessionId  // Track for validation
    // ...
} else if embeddedService.isAvailable {
    // Fallback to any available session
    let dispatched = embeddedService.dispatchPrompt(content)
    executingSessionId = embeddedService.activeSessionId
    // ...
} else {
    // Fall back to Terminal.app
    // ...
}
```

This enables future queue/chain targeting of specific sessions.
  </action>
  <verify>Build succeeds; ExecutionContext has targetSessionId property; ExecutionManager.execute has targetSessionId parameter</verify>
  <done>ExecutionContext and ExecutionManager support session targeting, future-proofing multi-session queue dispatch</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build` succeeds
2. EmbeddedTerminalService.swift exists with dispatchPrompt methods
3. ExecutionManager uses EmbeddedTerminalService.shared (grep confirms)
4. executingSessionId tracked in ExecutionStateMachine
5. handleHookCompletion validates session ID
</verification>

<success_criteria>
- EmbeddedTerminalService created with same dispatch API pattern as TerminalService
- ExecutionManager routes through EmbeddedTerminalService (not direct bridge access)
- Session activity updated on each dispatch
- Hook completions validated against executing session ID
- ExecutionContext supports optional targetSessionId for future multi-session queue
- All code compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/20-service-integration/20-01-SUMMARY.md`
</output>

---
phase: 20-service-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dispatch/Services/EmbeddedTerminalService.swift
  - Dispatch/Services/ExecutionStateMachine.swift
autonomous: true

must_haves:
  truths:
    - "Queue Run Next dispatches prompt to embedded terminal successfully"
    - "Chain execution dispatches sequence to embedded terminal"
    - "Session shows updated activity after prompt dispatch"
    - "Hook completion only triggers for the session that is executing"
  artifacts:
    - path: "Dispatch/Services/EmbeddedTerminalService.swift"
      provides: "Dispatch interface for embedded terminals"
      min_lines: 40
      exports: ["EmbeddedTerminalService"]
  key_links:
    - from: "Dispatch/Services/ExecutionStateMachine.swift"
      to: "EmbeddedTerminalService"
      via: "Uses EmbeddedTerminalService.shared for dispatch"
      pattern: "EmbeddedTerminalService\\.shared"
    - from: "Dispatch/Services/EmbeddedTerminalService.swift"
      to: "EmbeddedTerminalBridge"
      via: "Delegates to bridge for actual dispatch"
      pattern: "EmbeddedTerminalBridge\\.shared"
    - from: "Dispatch/Services/EmbeddedTerminalService.swift"
      to: "TerminalSessionManager"
      via: "Updates activity timestamp on dispatch"
      pattern: "sessionManager\\.updateSessionActivity"
---

<objective>
Create EmbeddedTerminalService as explicit dispatch interface and wire ExecutionManager

Purpose: INTG-01 requires explicit service class implementing dispatch interface (parallel to TerminalService). INTG-04 requires integration with ExecutionStateMachine for state transitions.

Output:
- EmbeddedTerminalService.swift - Thin service wrapper around EmbeddedTerminalBridge
- Updated ExecutionManager - Uses EmbeddedTerminalService, tracks executing session for validation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-service-integration/20-RESEARCH.md

@Dispatch/Services/EmbeddedTerminalBridge.swift
@Dispatch/Services/ExecutionStateMachine.swift
@Dispatch/Services/TerminalService.swift
@Dispatch/Services/TerminalSessionManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmbeddedTerminalService</name>
  <files>Dispatch/Services/EmbeddedTerminalService.swift</files>
  <action>
Create EmbeddedTerminalService as explicit service class parallel to TerminalService:

```swift
/// Service for dispatching prompts to embedded terminals (PTY-based)
/// Wraps EmbeddedTerminalBridge to provide service-layer interface
@MainActor
final class EmbeddedTerminalService {
    static let shared = EmbeddedTerminalService()

    private let bridge = EmbeddedTerminalBridge.shared
    private let sessionManager = TerminalSessionManager.shared

    private init() {}

    // MARK: - Availability

    /// Check if any embedded terminal is available for dispatch
    var isAvailable: Bool { bridge.isAvailable }

    /// Check if specific session is available
    func isAvailable(sessionId: UUID) -> Bool {
        bridge.isAvailable(sessionId: sessionId)
    }

    // MARK: - Session Info

    /// Currently active session ID (for targeting/tracking)
    var activeSessionId: UUID? { sessionManager.activeSessionId }

    /// Get terminal for session (for completion monitoring)
    func getTerminal(for sessionId: UUID) -> LocalProcessTerminalView? {
        bridge.getTerminal(for: sessionId)
    }

    // MARK: - Dispatch

    /// Dispatch prompt to active session
    /// Updates session activity timestamp on successful dispatch
    @discardableResult
    func dispatchPrompt(_ content: String) -> Bool {
        let result = bridge.dispatchPrompt(content)
        if result, let sessionId = sessionManager.activeSessionId {
            sessionManager.updateSessionActivity(sessionId)
        }
        return result
    }

    /// Dispatch prompt to specific session
    /// Updates session activity timestamp on successful dispatch
    @discardableResult
    func dispatchPrompt(_ content: String, to sessionId: UUID) -> Bool {
        let result = bridge.dispatchPrompt(content, to: sessionId)
        if result {
            sessionManager.updateSessionActivity(sessionId)
        }
        return result
    }
}
```

Key points:
- Singleton pattern matches TerminalService
- @MainActor for SwiftUI compatibility
- Delegates to EmbeddedTerminalBridge (avoids duplication)
- Updates session activity on dispatch (PERS-05 compliance)
- Both legacy (active session) and session-aware APIs
  </action>
  <verify>
File exists at Dispatch/Services/EmbeddedTerminalService.swift with EmbeddedTerminalService class.
grep "dispatchPrompt" confirms both dispatch methods exist.
grep "updateSessionActivity" in TerminalSessionManager.swift confirms method exists (should find line ~196).
  </verify>
  <done>EmbeddedTerminalService.swift created with parallel API to TerminalService, activity tracking on dispatch</done>
</task>

<task type="auto">
  <name>Task 2: Wire ExecutionManager to EmbeddedTerminalService</name>
  <files>Dispatch/Services/ExecutionStateMachine.swift</files>
  <action>
Update ExecutionManager.execute() to use EmbeddedTerminalService instead of direct EmbeddedTerminalBridge access:

1. In execute() method, replace:
```swift
let bridge = EmbeddedTerminalBridge.shared

if bridge.isAvailable {
    let dispatched = bridge.dispatchPrompt(content)
```

With:
```swift
let embeddedService = EmbeddedTerminalService.shared

if embeddedService.isAvailable {
    let dispatched = embeddedService.dispatchPrompt(content)
```

2. Update terminal monitoring to get terminal from service:
```swift
if let sessionId = embeddedService.activeSessionId,
   let terminal = embeddedService.getTerminal(for: sessionId) {
    stateMachine.startEmbeddedTerminalMonitoring(terminal: terminal)
}
```

This wires ExecutionManager through the service layer rather than directly to the bridge.
  </action>
  <verify>
Build succeeds: xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build
grep "EmbeddedTerminalService.shared" in ExecutionStateMachine.swift confirms usage.
  </verify>
  <done>ExecutionManager uses EmbeddedTerminalService for dispatch, service layer properly integrated</done>
</task>

<task type="auto">
  <name>Task 3: Add session validation in hook completion</name>
  <files>Dispatch/Services/ExecutionStateMachine.swift</files>
  <action>
Add session tracking and validation to prevent cross-session completion confusion:

1. Add property to ExecutionStateMachine class:
```swift
private var executingSessionId: UUID?
```

2. In beginSending(), after setting context, set executingSessionId if embedded terminal:
```swift
// Track executing session for validation (set by ExecutionManager after dispatch)
func setExecutingSession(_ sessionId: UUID?) {
    executingSessionId = sessionId
    if let id = sessionId {
        logDebug("Tracking executing session: \(id)", category: .execution)
    }
}
```

3. In transitionToIdle(), clear the session:
```swift
executingSessionId = nil
```

4. Update handleHookCompletion() to validate session:
```swift
func handleHookCompletion(sessionId: String?) {
    guard state == .executing else {
        logDebug("Ignoring hook completion in state: \(state)", category: .execution)
        return
    }

    // Validate session if we have expected session ID
    if let executing = executingSessionId,
       let hookSession = sessionId,
       let hookUUID = UUID(uuidString: hookSession),
       hookUUID != executing {
        logWarning("Ignoring hook from different session: expected \(executing), got \(hookSession)", category: .execution)
        return
    }

    logInfo("Completion detected via hook (session: \(sessionId ?? "unknown"))", category: .execution)
    markCompleted(result: .success)
}
```

5. In ExecutionManager.execute(), after successful dispatch, set the session:
```swift
if embeddedService.isAvailable {
    let dispatched = embeddedService.dispatchPrompt(content)
    guard dispatched else {
        throw TerminalServiceError.scriptExecutionFailed("Embedded terminal dispatch failed")
    }

    // Track session for completion validation (INTG-04)
    stateMachine.setExecutingSession(embeddedService.activeSessionId)

    // Transition to executing
    stateMachine.beginExecuting()
    // ...
}
```

This prevents hook completions from a different session triggering completion for the wrong execution.
  </action>
  <verify>
Build succeeds.
grep "executingSessionId" in ExecutionStateMachine.swift confirms property exists.
grep "setExecutingSession" confirms method exists.
Test state transitions manually: IDLE -> SENDING -> EXECUTING -> COMPLETED cycle works end-to-end.
  </verify>
  <done>Session validation added to handleHookCompletion, no cross-session confusion possible</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `xcodebuild -project Dispatch.xcodeproj -scheme Dispatch -configuration Debug build` succeeds
2. EmbeddedTerminalService.swift exists with dispatchPrompt methods
3. ExecutionManager uses EmbeddedTerminalService.shared (grep confirms)
4. executingSessionId tracked in ExecutionStateMachine
5. handleHookCompletion validates session ID
6. State transitions work end-to-end: IDLE -> SENDING -> EXECUTING -> COMPLETED -> IDLE

Manual verification of state transitions:
- Build and run app
- Send a prompt via queue or direct dispatch
- Observe logs showing state transitions
- Confirm completion detection works (via hook or pattern)
</verification>

<success_criteria>
- EmbeddedTerminalService created with same dispatch API pattern as TerminalService
- ExecutionManager routes through EmbeddedTerminalService (not direct bridge access)
- Session activity updated on each dispatch
- Hook completions validated against executing session ID
- State transitions (IDLE -> SENDING -> EXECUTING -> COMPLETED) work correctly
- All code compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/20-service-integration/20-01-SUMMARY.md`
</output>

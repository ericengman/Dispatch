---
phase: 08-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/.claude/lib/dispatch.sh
autonomous: true

must_haves:
  truths:
    - "Library file exists at ~/.claude/lib/dispatch.sh and is sourceable"
    - "dispatch_init returns a valid screenshot directory path when Dispatch is running"
    - "dispatch_init returns a fallback temp path with clear message when Dispatch is not running"
    - "dispatch_finalize marks the run complete via Dispatch API"
    - "State persists between bash calls via temp file"
    - "Project name comes from git root, not current directory"
  artifacts:
    - path: "~/.claude/lib/dispatch.sh"
      provides: "Shared Dispatch integration functions"
      min_lines: 80
      exports: ["dispatch_init", "dispatch_finalize", "dispatch_get_state"]
  key_links:
    - from: "dispatch_init"
      to: "http://localhost:19847/screenshots/run"
      via: "curl POST request"
      pattern: "curl.*screenshots/run"
    - from: "dispatch_finalize"
      to: "http://localhost:19847/screenshots/complete"
      via: "curl POST request"
      pattern: "curl.*screenshots/complete"
    - from: "dispatch_init"
      to: "/tmp/dispatch-state.XXXXXX"
      via: "mktemp state file"
      pattern: "mktemp.*dispatch"
---

<objective>
Create the shared bash library `~/.claude/lib/dispatch.sh` that provides Dispatch integration functions for Claude Code skills.

Purpose: Eliminate duplicated integration code across skills (40-60 lines per skill) by centralizing into one sourceable library. This is the foundation for all subsequent phases.

Output: A complete, tested bash library file with dispatch_init, dispatch_finalize, and state persistence functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-foundation/08-RESEARCH.md

# API endpoints verified in:
@Dispatch/Services/HookServer.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dispatch.sh library with all functions</name>
  <files>~/.claude/lib/dispatch.sh</files>
  <action>
Create the directory `~/.claude/lib/` if it doesn't exist, then create `dispatch.sh` with:

**Header section:**
- Shebang: `#!/bin/bash`
- Library version constant: `DISPATCH_LIB_VERSION="1.0.0"`
- Default port constant: `DISPATCH_DEFAULT_PORT=19847`

**Helper function - dispatch_get_project_name:**
- Use `git rev-parse --show-toplevel` to get repo root
- Extract basename as project name
- Fallback to "unknown" if not in git repo

**Helper function - dispatch_check_health:**
- curl GET to `http://localhost:$DISPATCH_DEFAULT_PORT/health`
- Return 0 if response contains `"status":"ok"`, return 1 otherwise
- Use `-s` for silent and `2>/dev/null` to suppress errors

**Main function - dispatch_init:**
- Parameters: `$1` = run_name (optional, defaults to "Screenshot Run"), `$2` = device_info (optional)
- Create state file: `STATE_FILE=$(mktemp /tmp/dispatch-state.XXXXXX)`
- Call dispatch_check_health first
- If Dispatch available:
  - POST to `/screenshots/run` with JSON: `{"project":"$PROJECT","name":"$RUN_NAME","device":"$DEVICE"}`
  - Parse response using grep/cut (NOT jq - avoid external dependencies)
  - Extract runId and path from response
  - Write to state file: `DISPATCH_AVAILABLE=true`, `DISPATCH_RUN_ID=xxx`, `DISPATCH_SCREENSHOT_PATH=xxx`, `DISPATCH_STATE_FILE=xxx`
  - Echo: "Dispatch run created: $RUN_ID"
  - Echo: "Screenshots will be saved to: $PATH"
- If Dispatch NOT available:
  - Create fallback dir: `/tmp/screenshots-$(date +%s)`
  - Write to state file: `DISPATCH_AVAILABLE=false`, `DISPATCH_RUN_ID=`, `DISPATCH_SCREENSHOT_PATH=$FALLBACK`
  - Echo: "Dispatch not running - screenshots saved to: $FALLBACK"
- Export `DISPATCH_STATE_FILE` so subsequent calls can find the state

**Main function - dispatch_finalize:**
- No parameters (reads state from DISPATCH_STATE_FILE)
- Source the state file to get RUN_ID and AVAILABLE flag
- If DISPATCH_AVAILABLE=true and RUN_ID is set:
  - POST to `/screenshots/complete` with JSON: `{"runId":"$RUN_ID"}`
  - Echo: "Dispatch run finalized - screenshots ready for review"
- If not available:
  - Echo: "Dispatch was not running - screenshots remain in: $DISPATCH_SCREENSHOT_PATH"
- Clean up state file: `rm -f "$DISPATCH_STATE_FILE"`

**Utility function - dispatch_get_state:**
- Source and echo the state file contents (for debugging)

**Important implementation details:**
- Use single quotes around JSON with variable interpolation: `'{"project":"'"$VAR"'"}'`
- All echo statements go to stderr so they don't interfere with command substitution
- Functions return 0 on success, 1 on failure
- Do NOT use trap for cleanup - skills may call finalize explicitly
  </action>
  <verify>
Run these commands to verify the library:
```bash
# Check file exists and is readable
ls -la ~/.claude/lib/dispatch.sh

# Check it sources without errors
bash -c 'source ~/.claude/lib/dispatch.sh && echo "Sourced OK"'

# Check functions are defined
bash -c 'source ~/.claude/lib/dispatch.sh && type dispatch_init && type dispatch_finalize'
```
  </verify>
  <done>
- Library file exists at ~/.claude/lib/dispatch.sh
- File is sourceable without errors
- dispatch_init, dispatch_finalize, dispatch_get_state functions are defined
- DISPATCH_LIB_VERSION is set to "1.0.0"
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify library functions with Dispatch running</name>
  <files>None (verification only)</files>
  <action>
Test the library functions end-to-end. This requires Dispatch to be running.

**Test 1 - Git root detection:**
```bash
cd /Users/eric/Dispatch
source ~/.claude/lib/dispatch.sh
dispatch_get_project_name
# Expected: "Dispatch"
```

**Test 2 - Health check (Dispatch running):**
```bash
source ~/.claude/lib/dispatch.sh
dispatch_check_health && echo "Dispatch is running" || echo "Dispatch not running"
```

**Test 3 - Full init flow (Dispatch running):**
```bash
cd /Users/eric/Dispatch
source ~/.claude/lib/dispatch.sh
dispatch_init "Test Run" "iPhone 15 Pro"
# Expected output includes "Dispatch run created:" and a path
# Check state file was created
cat "$DISPATCH_STATE_FILE"
```

**Test 4 - Full finalize flow:**
```bash
source ~/.claude/lib/dispatch.sh
source "$DISPATCH_STATE_FILE"
dispatch_finalize
# Expected: "Dispatch run finalized"
```

**Test 5 - Fallback mode (stop Dispatch first or test on different port):**
```bash
# Test fallback by using wrong port
DISPATCH_DEFAULT_PORT=19999 source ~/.claude/lib/dispatch.sh
dispatch_init "Fallback Test"
# Expected: "Dispatch not running - screenshots saved to: /tmp/screenshots-..."
cat "$DISPATCH_STATE_FILE"  # Should show DISPATCH_AVAILABLE=false
```

If any test fails, fix the library and re-test.
  </action>
  <verify>
All 5 tests pass:
1. dispatch_get_project_name returns "Dispatch" from /Users/eric/Dispatch
2. dispatch_check_health returns success when Dispatch is running
3. dispatch_init creates state file with valid RUN_ID and PATH
4. dispatch_finalize completes without error
5. Fallback mode works when Dispatch unavailable
  </verify>
  <done>
- Git root detection works from any subdirectory
- Health check correctly detects Dispatch availability
- Init creates screenshot run and returns valid path
- Finalize marks run complete
- Fallback provides temp directory with clear message
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. **Library exists and is sourceable:**
   ```bash
   source ~/.claude/lib/dispatch.sh && echo "Version: $DISPATCH_LIB_VERSION"
   ```

2. **Functions are callable:**
   ```bash
   source ~/.claude/lib/dispatch.sh
   type dispatch_init dispatch_finalize dispatch_get_project_name dispatch_check_health
   ```

3. **Integration test (with Dispatch running):**
   ```bash
   cd /Users/eric/Dispatch
   source ~/.claude/lib/dispatch.sh
   dispatch_init "Integration Test" "Test Device"
   echo "Path: $DISPATCH_SCREENSHOT_PATH"
   dispatch_finalize
   ```

4. **State file cleanup verified:**
   ```bash
   ls /tmp/dispatch-state.* 2>/dev/null | wc -l  # Should be 0 after finalize
   ```
</verification>

<success_criteria>
- [x] FNDTN-01: Library exists at ~/.claude/lib/dispatch.sh
- [x] FNDTN-02: dispatch_init checks availability and creates run via POST /screenshots/run
- [x] FNDTN-03: dispatch_finalize marks run complete via POST /screenshots/complete
- [x] FNDTN-04: State persists via /tmp/dispatch-state.XXXXXX temp file
- [x] FNDTN-05: Fallback path returned with clear message when Dispatch not running
- [x] FNDTN-06: Project name derived from git rev-parse --show-toplevel
</success_criteria>

<output>
After completion, create `.planning/phases/08-foundation/08-01-SUMMARY.md`
</output>

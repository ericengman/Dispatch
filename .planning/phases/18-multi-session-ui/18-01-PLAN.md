---
phase: 18-multi-session-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dispatch/Models/TerminalSession.swift
  - Dispatch/Services/TerminalSessionManager.swift
  - Dispatch/Services/EmbeddedTerminalBridge.swift
  - Dispatch/Views/Terminal/EmbeddedTerminalView.swift
autonomous: true

must_haves:
  truths:
    - "Sessions have unique identities (UUID)"
    - "Manager tracks collection of sessions"
    - "Manager enforces session limit (max 4)"
    - "Active session is explicitly tracked"
    - "Bridge can dispatch to specific session by ID"
  artifacts:
    - path: "Dispatch/Models/TerminalSession.swift"
      provides: "Session model with UUID identity"
      exports: ["TerminalSession"]
    - path: "Dispatch/Services/TerminalSessionManager.swift"
      provides: "Session collection management"
      exports: ["TerminalSessionManager"]
    - path: "Dispatch/Services/EmbeddedTerminalBridge.swift"
      provides: "Multi-session dispatch registry"
      exports: ["register(sessionId:coordinator:terminal:)", "dispatchPrompt(_:to:)"]
    - path: "Dispatch/Views/Terminal/EmbeddedTerminalView.swift"
      provides: "Session-aware terminal view"
      exports: ["EmbeddedTerminalView"]
  key_links:
    - from: "TerminalSession"
      to: "TerminalSessionManager.sessions"
      via: "array membership"
      pattern: "sessions\\.append"
    - from: "EmbeddedTerminalView"
      to: "EmbeddedTerminalBridge"
      via: "register with sessionId"
      pattern: "register\\(sessionId:"
    - from: "TerminalSessionManager.activeSessionId"
      to: "EmbeddedTerminalBridge.dispatchPrompt"
      via: "default session targeting"
      pattern: "activeSessionId"
---

<objective>
Create session management infrastructure for multi-terminal support.

Purpose: Enable tracking and managing multiple terminal sessions with unique identities, enforced limits, and explicit active session targeting. This foundation allows Plan 18-02 to build the UI layer.

Output: TerminalSession model, TerminalSessionManager singleton, updated EmbeddedTerminalBridge with registry pattern, updated EmbeddedTerminalView with sessionId parameter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-multi-session-ui/18-RESEARCH.md

@Dispatch/Services/EmbeddedTerminalBridge.swift
@Dispatch/Views/Terminal/EmbeddedTerminalView.swift
@Dispatch/Services/TerminalProcessRegistry.swift
@Dispatch/Services/LoggingService.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TerminalSession model and TerminalSessionManager</name>
  <files>
    Dispatch/Models/TerminalSession.swift
    Dispatch/Services/TerminalSessionManager.swift
  </files>
  <action>
Create TerminalSession.swift in Dispatch/Models/:

```swift
// TerminalSession.swift
// Observable model representing a single terminal session

import Foundation
import SwiftTerm

@Observable
final class TerminalSession: Identifiable {
    let id: UUID
    var name: String
    let createdAt: Date

    // Coordinator reference set by EmbeddedTerminalView
    weak var coordinator: EmbeddedTerminalView.Coordinator?

    // Terminal reference for monitoring
    weak var terminal: LocalProcessTerminalView?

    init(name: String? = nil) {
        self.id = UUID()
        self.name = name ?? "Session \(UUID().uuidString.prefix(8))"
        self.createdAt = Date()
    }

    var isReady: Bool {
        coordinator?.isReadyForDispatch ?? false
    }
}
```

Create TerminalSessionManager.swift in Dispatch/Services/:

```swift
// TerminalSessionManager.swift
// Manages collection of terminal sessions, active session, and layout mode

import Foundation

@Observable
@MainActor
final class TerminalSessionManager {
    static let shared = TerminalSessionManager()

    private(set) var sessions: [TerminalSession] = []
    var activeSessionId: UUID?
    var layoutMode: LayoutMode = .single
    let maxSessions: Int = 4  // SESS-06: limit to prevent resource exhaustion

    enum LayoutMode: String, CaseIterable {
        case single          // Focus mode (one session fullscreen)
        case horizontalSplit // Side-by-side
        case verticalSplit   // Above-and-below
    }

    private init() {}

    var activeSession: TerminalSession? {
        sessions.first { $0.id == activeSessionId }
    }

    var canCreateSession: Bool {
        sessions.count < maxSessions
    }

    @discardableResult
    func createSession(name: String? = nil) -> TerminalSession? {
        guard canCreateSession else {
            logWarning("Cannot create session: max limit (\(maxSessions)) reached", category: .terminal)
            return nil
        }

        let session = TerminalSession(name: name)
        sessions.append(session)

        // Auto-activate if first session
        if activeSessionId == nil {
            activeSessionId = session.id
        }

        logInfo("Created session: \(session.name) (\(session.id))", category: .terminal)
        return session
    }

    func closeSession(_ sessionId: UUID) {
        guard let index = sessions.firstIndex(where: { $0.id == sessionId }) else {
            logWarning("Cannot close session: \(sessionId) not found", category: .terminal)
            return
        }

        let session = sessions[index]
        logInfo("Closing session: \(session.name)", category: .terminal)

        // Clear references (triggers coordinator deinit -> process cleanup)
        session.coordinator = nil
        session.terminal = nil

        sessions.remove(at: index)

        // If active session closed, select another
        if activeSessionId == sessionId {
            activeSessionId = sessions.first?.id
            logDebug("Active session changed to: \(activeSessionId?.uuidString ?? "none")", category: .terminal)
        }
    }

    func setActiveSession(_ sessionId: UUID) {
        guard sessions.contains(where: { $0.id == sessionId }) else {
            logWarning("Cannot activate session: \(sessionId) not found", category: .terminal)
            return
        }
        activeSessionId = sessionId
        logDebug("Active session set to: \(sessionId)", category: .terminal)
    }

    func toggleLayoutMode() {
        switch layoutMode {
        case .single:
            layoutMode = .horizontalSplit
        case .horizontalSplit:
            layoutMode = .verticalSplit
        case .verticalSplit:
            layoutMode = .single
        }
        logDebug("Layout mode changed to: \(layoutMode.rawValue)", category: .terminal)
    }

    func setLayoutMode(_ mode: LayoutMode) {
        layoutMode = mode
        logDebug("Layout mode set to: \(mode.rawValue)", category: .terminal)
    }
}
```

Key design decisions:
- Use @Observable (Swift 5.9+) not ObservableObject for modern SwiftUI integration
- Weak references to coordinator/terminal to avoid retain cycles
- maxSessions = 4 per SESS-06 requirement (each session ~200MB RAM)
- Auto-activate first session, auto-select next on close
- LayoutMode enum supports future expansion (quad view)
  </action>
  <verify>
Build succeeds: `xcodebuild -scheme Dispatch -destination 'platform=macOS' build 2>&1 | grep -E "(error:|Build Succeeded)"`
  </verify>
  <done>
TerminalSession model exists with UUID identity, name, coordinator/terminal refs.
TerminalSessionManager singleton manages sessions array with create/close/activate methods.
maxSessions limit enforced (returns nil if exceeded).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update EmbeddedTerminalBridge to registry pattern</name>
  <files>Dispatch/Services/EmbeddedTerminalBridge.swift</files>
  <action>
Modify EmbeddedTerminalBridge.swift to support multiple sessions:

1. Replace single `activeCoordinator`/`activeTerminal` with dictionaries keyed by UUID
2. Add `register(sessionId:coordinator:terminal:)` method
3. Add `unregister(sessionId:)` method
4. Add `dispatchPrompt(_:to:)` for explicit session targeting
5. Keep `dispatchPrompt(_:)` as convenience that uses activeSessionId
6. Add `isAvailable(sessionId:)` check
7. Add `getTerminal(for:)` for completion monitoring

```swift
@MainActor
final class EmbeddedTerminalBridge: ObservableObject {
    static let shared = EmbeddedTerminalBridge()

    // Registry: session ID -> coordinator/terminal
    private var sessionCoordinators: [UUID: EmbeddedTerminalView.Coordinator] = [:]
    private var sessionTerminals: [UUID: LocalProcessTerminalView] = [:]

    // Keep published for backward compatibility during transition
    @Published private(set) var activeCoordinator: EmbeddedTerminalView.Coordinator?
    @Published private(set) var activeTerminal: LocalProcessTerminalView?

    private init() {}

    // MARK: - Multi-Session Registry

    func register(sessionId: UUID, coordinator: EmbeddedTerminalView.Coordinator, terminal: LocalProcessTerminalView) {
        sessionCoordinators[sessionId] = coordinator
        sessionTerminals[sessionId] = terminal

        // Update legacy single-session properties if this is active session
        if TerminalSessionManager.shared.activeSessionId == sessionId {
            activeCoordinator = coordinator
            activeTerminal = terminal
        }

        logInfo("Session \(sessionId) registered for dispatch", category: .terminal)
    }

    func unregister(sessionId: UUID) {
        sessionCoordinators.removeValue(forKey: sessionId)
        sessionTerminals.removeValue(forKey: sessionId)

        // Clear legacy properties if this was active
        if TerminalSessionManager.shared.activeSessionId == sessionId {
            activeCoordinator = nil
            activeTerminal = nil
        }

        logInfo("Session \(sessionId) unregistered", category: .terminal)
    }

    // MARK: - Legacy Single-Session API (for backward compatibility)

    func register(coordinator: EmbeddedTerminalView.Coordinator, terminal: LocalProcessTerminalView) {
        // Legacy: create/use default session
        let sessionId = TerminalSessionManager.shared.activeSessionId ?? UUID()
        register(sessionId: sessionId, coordinator: coordinator, terminal: terminal)
    }

    func unregister() {
        // Legacy: unregister active session
        if let sessionId = TerminalSessionManager.shared.activeSessionId {
            unregister(sessionId: sessionId)
        } else {
            // Fallback: clear all (shouldn't happen)
            sessionCoordinators.removeAll()
            sessionTerminals.removeAll()
            activeCoordinator = nil
            activeTerminal = nil
        }
    }

    // MARK: - Availability Checks

    var isAvailable: Bool {
        guard let sessionId = TerminalSessionManager.shared.activeSessionId else { return false }
        return isAvailable(sessionId: sessionId)
    }

    func isAvailable(sessionId: UUID) -> Bool {
        sessionCoordinators[sessionId]?.isReadyForDispatch ?? false
    }

    // MARK: - Dispatch

    func dispatchPrompt(_ prompt: String) -> Bool {
        guard let sessionId = TerminalSessionManager.shared.activeSessionId else {
            logDebug("Cannot dispatch: no active session", category: .terminal)
            return false
        }
        return dispatchPrompt(prompt, to: sessionId)
    }

    func dispatchPrompt(_ prompt: String, to sessionId: UUID) -> Bool {
        guard let coordinator = sessionCoordinators[sessionId] else {
            logDebug("Cannot dispatch to session \(sessionId): not registered", category: .terminal)
            return false
        }
        return coordinator.dispatchPrompt(prompt)
    }

    // MARK: - Terminal Access

    func getTerminal(for sessionId: UUID) -> LocalProcessTerminalView? {
        sessionTerminals[sessionId]
    }

    var registeredSessionCount: Int {
        sessionCoordinators.count
    }
}
```

Note: Keep legacy `register(coordinator:terminal:)` and `unregister()` methods for backward compatibility with existing code. They delegate to the new session-aware methods.
  </action>
  <verify>
Build succeeds and existing terminal still works (legacy API preserved).
  </verify>
  <done>
EmbeddedTerminalBridge has sessionCoordinators/sessionTerminals dictionaries.
register(sessionId:) and unregister(sessionId:) methods exist.
dispatchPrompt(_:to:) dispatches to specific session.
Legacy single-session API still works via delegation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update EmbeddedTerminalView with sessionId parameter</name>
  <files>Dispatch/Views/Terminal/EmbeddedTerminalView.swift</files>
  <action>
Modify EmbeddedTerminalView.swift to accept optional sessionId:

1. Add `sessionId: UUID?` parameter (optional for backward compatibility)
2. Store sessionId in Coordinator
3. Register with bridge using sessionId
4. Unregister with sessionId in deinit
5. Update session model references if sessionId provided

```swift
struct EmbeddedTerminalView: NSViewRepresentable {
    typealias NSViewType = LocalProcessTerminalView

    // Session identity (nil uses legacy single-session mode)
    var sessionId: UUID?

    // Launch mode determines what process to spawn
    var launchMode: TerminalLaunchMode = .shell

    // Optional callback for process exit
    var onProcessExit: ((Int32?) -> Void)?

    func makeNSView(context: Context) -> LocalProcessTerminalView {
        logDebug("Creating embedded terminal view (session: \(sessionId?.uuidString ?? "legacy"))", category: .terminal)

        let terminal = LocalProcessTerminalView(frame: .zero)
        terminal.processDelegate = context.coordinator

        // Store references in coordinator
        context.coordinator.terminalView = terminal
        context.coordinator.sessionId = sessionId

        // Register with bridge
        if let sessionId = sessionId {
            EmbeddedTerminalBridge.shared.register(sessionId: sessionId, coordinator: context.coordinator, terminal: terminal)

            // Update session model references
            if let session = TerminalSessionManager.shared.sessions.first(where: { $0.id == sessionId }) {
                session.coordinator = context.coordinator
                session.terminal = terminal
            }
        } else {
            // Legacy single-session registration
            EmbeddedTerminalBridge.shared.register(coordinator: context.coordinator, terminal: terminal)
        }

        // Launch appropriate process based on mode
        switch launchMode {
        case .shell:
            let shell = ProcessInfo.processInfo.environment["SHELL"] ?? "/bin/bash"
            logInfo("Starting shell: \(shell)", category: .terminal)
            terminal.startProcess(executable: shell)

            let pid = terminal.process.shellPid
            if pid > 0 {
                TerminalProcessRegistry.shared.register(pid: pid)
                logInfo("Terminal process started with PID \(pid)", category: .terminal)
            }

        case let .claudeCode(workingDirectory, skipPermissions):
            logInfo("Launching Claude Code mode", category: .terminal)
            ClaudeCodeLauncher.shared.launchClaudeCode(
                in: terminal,
                workingDirectory: workingDirectory,
                skipPermissions: skipPermissions
            )
        }

        return terminal
    }

    func updateNSView(_: LocalProcessTerminalView, context: Context) {
        context.coordinator.onProcessExit = onProcessExit
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(sessionId: sessionId, onProcessExit: onProcessExit)
    }

    class Coordinator: NSObject, LocalProcessTerminalViewDelegate {
        var sessionId: UUID?
        var onProcessExit: ((Int32?) -> Void)?
        var terminalView: LocalProcessTerminalView?

        init(sessionId: UUID?, onProcessExit: ((Int32?) -> Void)?) {
            self.sessionId = sessionId
            self.onProcessExit = onProcessExit
            super.init()
        }

        deinit {
            logDebug("Coordinator deinit (session: \(sessionId?.uuidString ?? "legacy"))", category: .terminal)

            // Unregister from bridge
            MainActor.assumeIsolated {
                if let sessionId = sessionId {
                    EmbeddedTerminalBridge.shared.unregister(sessionId: sessionId)
                } else {
                    EmbeddedTerminalBridge.shared.unregister()
                }
            }

            guard let terminal = terminalView else { return }
            let pid = terminal.process.shellPid

            TerminalProcessRegistry.shared.terminateProcessGroupGracefully(pgid: pid, timeout: 2.0)
            TerminalProcessRegistry.shared.unregister(pid: pid)

            terminalView = nil
        }

        // ... rest of delegate methods unchanged ...

        func processTerminated(source _: TerminalView, exitCode: Int32?) {
            logDebug("Terminal process exited (session: \(sessionId?.uuidString ?? "legacy")): \(exitCode ?? -1)", category: .terminal)

            if let terminal = terminalView {
                TerminalProcessRegistry.shared.unregister(pid: terminal.process.shellPid)
            }

            terminalView = nil
            DispatchQueue.main.async {
                self.onProcessExit?(exitCode)
            }
        }

        func dispatchPrompt(_ prompt: String) -> Bool {
            guard let terminal = terminalView else {
                logDebug("Cannot dispatch (session: \(sessionId?.uuidString ?? "legacy")): no terminal", category: .terminal)
                return false
            }

            let fullPrompt = prompt.hasSuffix("\n") ? prompt : prompt + "\n"
            logInfo("Dispatching prompt (\(fullPrompt.count) chars) to session \(sessionId?.uuidString ?? "legacy")", category: .terminal)
            terminal.send(txt: fullPrompt)

            return true
        }

        // ... sendIfRunning, isReadyForDispatch, isTerminalActive, delegate methods unchanged ...
    }
}
```

Key changes:
- sessionId parameter (optional for backward compatibility with MainView)
- Coordinator stores sessionId
- Register/unregister uses sessionId when available
- Log messages include session ID for debugging
  </action>
  <verify>
Build succeeds. Existing MainView terminal toggle still works (uses nil sessionId = legacy mode).
  </verify>
  <done>
EmbeddedTerminalView accepts optional sessionId parameter.
Coordinator stores and uses sessionId for bridge registration.
Legacy mode (nil sessionId) still works for backward compatibility.
  </done>
</task>

</tasks>

<verification>
1. Build verification:
   ```bash
   xcodebuild -scheme Dispatch -destination 'platform=macOS' build 2>&1 | tail -5
   ```
   Expected: "Build Succeeded"

2. Code structure verification:
   - TerminalSession.swift exists in Dispatch/Models/
   - TerminalSessionManager.swift exists in Dispatch/Services/
   - EmbeddedTerminalBridge has sessionCoordinators dictionary
   - EmbeddedTerminalView has sessionId parameter

3. Backward compatibility:
   - Run app, toggle terminal (Cmd+Shift+T)
   - Terminal should appear and work as before (legacy mode)
</verification>

<success_criteria>
1. TerminalSession model has UUID id, name, coordinator/terminal weak refs
2. TerminalSessionManager.shared manages sessions array with max 4 limit
3. TerminalSessionManager tracks activeSessionId
4. EmbeddedTerminalBridge has register(sessionId:)/unregister(sessionId:) methods
5. EmbeddedTerminalBridge.dispatchPrompt(_:to:) dispatches to specific session
6. EmbeddedTerminalView accepts sessionId parameter
7. Legacy single-terminal mode still works (MainView compatibility)
8. Project builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/18-multi-session-ui/18-01-SUMMARY.md`
</output>

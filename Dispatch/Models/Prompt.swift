//
//  Prompt.swift
//  Dispatch
//
//  Core Prompt model for storing and managing prompts
//

import Foundation
import SwiftData

@Model
final class Prompt {
    // MARK: - Properties

    var id: UUID
    var title: String
    var content: String
    var isStarred: Bool
    var createdAt: Date
    var updatedAt: Date
    var usageCount: Int

    // MARK: - Relationships

    var project: Project?

    @Relationship(deleteRule: .nullify, inverse: \ChainItem.prompt)
    var chainItems: [ChainItem] = []

    // MARK: - Initialization

    init(
        id: UUID = UUID(),
        title: String = "",
        content: String = "",
        isStarred: Bool = false,
        createdAt: Date = Date(),
        updatedAt: Date = Date(),
        usageCount: Int = 0,
        project: Project? = nil
    ) {
        self.id = id
        self.title = title
        self.content = content
        self.isStarred = isStarred
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.usageCount = usageCount
        self.project = project

        logDebug("Created prompt: '\(displayTitle)' (starred: \(isStarred))", category: .data)
    }

    // MARK: - Computed Properties

    /// Returns the user-provided title, or auto-generates from content
    var displayTitle: String {
        if !title.isEmpty {
            return title
        }
        return autoGeneratedTitle
    }

    /// Auto-generated title from first line or first 50 characters
    var autoGeneratedTitle: String {
        guard !content.isEmpty else {
            return "Untitled Prompt"
        }

        // Get first line
        let firstLine = content.components(separatedBy: .newlines).first ?? content

        // Truncate to 50 characters if needed
        if firstLine.count <= 50 {
            return firstLine.trimmingCharacters(in: .whitespaces)
        }

        let truncated = String(firstLine.prefix(50))
        // Try to break at a word boundary
        if let lastSpace = truncated.lastIndex(of: " ") {
            return String(truncated[..<lastSpace]) + "..."
        }
        return truncated + "..."
    }

    /// Preview text for list display (first 100 chars)
    var previewText: String {
        guard !content.isEmpty else {
            return ""
        }

        let singleLine = content.replacingOccurrences(of: "\n", with: " ")
            .trimmingCharacters(in: .whitespaces)

        if singleLine.count <= 100 {
            return singleLine
        }

        return String(singleLine.prefix(100)) + "..."
    }

    /// Checks if the prompt contains any placeholders
    var hasPlaceholders: Bool {
        PlaceholderPattern.hasPlaceholders(in: content)
    }

    /// Extracts all placeholder names from the content
    var placeholderNames: [String] {
        PlaceholderPattern.extractPlaceholders(from: content)
    }

    /// Returns relative time since last update
    var relativeUpdatedTime: String {
        RelativeTimeFormatter.format(updatedAt)
    }

    /// Returns relative time since creation
    var relativeCreatedTime: String {
        RelativeTimeFormatter.format(createdAt)
    }

    // MARK: - Methods

    /// Increments usage count and updates timestamp
    func recordUsage() {
        usageCount += 1
        updatedAt = Date()
        logDebug("Recorded usage for prompt '\(displayTitle)', count: \(usageCount)", category: .data)
    }

    /// Updates content and timestamp
    func updateContent(_ newContent: String) {
        content = newContent
        updatedAt = Date()
        logDebug("Updated content for prompt '\(displayTitle)'", category: .data)
    }

    /// Updates title
    func updateTitle(_ newTitle: String) {
        title = newTitle
        updatedAt = Date()
        logDebug("Updated title to '\(displayTitle)'", category: .data)
    }

    /// Toggles starred status
    func toggleStarred() {
        isStarred.toggle()
        updatedAt = Date()
        logDebug("Toggled starred status for '\(displayTitle)' to \(isStarred)", category: .data)
    }

    /// Creates a duplicate of this prompt
    func duplicate() -> Prompt {
        let copy = Prompt(
            title: title.isEmpty ? "" : "\(title) (Copy)",
            content: content,
            isStarred: false,
            project: project
        )
        logDebug("Duplicated prompt '\(displayTitle)'", category: .data)
        return copy
    }
}

// MARK: - Placeholder Pattern Utilities

enum PlaceholderPattern {
    /// Regex pattern for {{placeholder_name}}
    static let pattern = #"\{\{([a-zA-Z_][a-zA-Z0-9_]*)\}\}"#

    /// Checks if text contains any placeholders
    static func hasPlaceholders(in text: String) -> Bool {
        guard let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) else {
            return false
        }
        let range = NSRange(text.startIndex..., in: text)
        return regex.firstMatch(in: text, options: [], range: range) != nil
    }

    /// Extracts all unique placeholder names from text
    static func extractPlaceholders(from text: String) -> [String] {
        guard let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) else {
            return []
        }

        let range = NSRange(text.startIndex..., in: text)
        let matches = regex.matches(in: text, options: [], range: range)

        var placeholders: [String] = []
        var seen = Set<String>()

        for match in matches {
            if let captureRange = Range(match.range(at: 1), in: text) {
                let name = String(text[captureRange]).lowercased()
                if !seen.contains(name) {
                    seen.insert(name)
                    placeholders.append(name)
                }
            }
        }

        return placeholders
    }

    /// Replaces placeholders with provided values
    static func replacePlaceholders(in text: String, with values: [String: String]) -> String {
        var result = text

        for (name, value) in values {
            let placeholder = "{{\(name)}}"
            result = result.replacingOccurrences(
                of: placeholder,
                with: value,
                options: .caseInsensitive
            )
        }

        return result
    }
}

// MARK: - Relative Time Formatter

enum RelativeTimeFormatter {
    private static let formatter: RelativeDateTimeFormatter = {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter
    }()

    static func format(_ date: Date) -> String {
        formatter.localizedString(for: date, relativeTo: Date())
    }
}
